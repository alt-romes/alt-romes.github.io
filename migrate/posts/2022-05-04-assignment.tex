\documentclass[a4paper,10pt]{article}

%include polycode.fmt

\usepackage{csquotes}
\usepackage{xcolor}

% Highlight comments in darkgreen
\definecolor{darkgreen}{rgb}{0,0.5,0}
\newcommand{\commenthighlight}{\color{darkgreen}\quad-{}- }
\let\onelinecomment=\commenthighlight

% Highlight constructors in darkblue
\definecolor{darkblue}{rgb}{0,0,0.5}
\renewcommand{\Conid}[1]{\textcolor{darkblue}{\textit{#1}}}

% Highlight variables (if you want to do them in some other color, uncomment)
\renewcommand{\Varid}[1]{\textcolor{black}{\textit{#1}}}


\title{Lecture Exercises}
\author{Lectures \\ Rodrigo Mesquita}

\date{5 April, 2022}

\begin{document}
\maketitle

% These exercises are exploration oriented: They should be challenging (we'll
% tune that) enough that you should need to search for extra information on your
% own, they should make you \emph{think}, and most importantly they should create
% \emph{questions!}.  In the lectures, besides everything else, we'll retrace
% difficulties in your \emph{exploration path} and in coming up with solutions,
% to the end goal of you becoming \emph{self sufficient} -- and in time, no
% longer have those difficulties.

This problem set/project is about writing a simplified clone of the \emph{ed
line editor}. This should be hard enough as to take at least 10 hours of work.
Since the project is big, it should be delivered in multiple stages, rather
than just one final, complete, delivery. This way I can follow your progress
and better orient you.

The work to be delivered at the \textbf{first stage} should be at least one
haskell module containing \emph{datatypes} and \emph{functions} representing
the domain of your problem -- use your judgment to choose whether or not to
implement the functions, but \emph{do} write the types first! To quote Edwin
Brady:

\begin{displayquote}
In type-driven development, we use types as a tool for constructing
programs. We put the type first, treating it as a plan for a program, and use
the compiler and type checker as our assistant, guiding us to a complete and
working program that satisfies the type. The more expressive the type is that
we give up front, the more confidence we can have that the resulting program
will be correct.
\end{displayquote}

The main idea is to be guided by types and model the domain of the problem in
Haskell. Remember you can use @undefined@ to compile the program without having
a certain implementation, and so you can write the types and important bits
upfront and use the compiler to verify its correctness. Forcing the skeleton of
the program to be ready before any actual part of it is a nice way to exercise
"thinking of the problem before programming" and become stronger at writing
more beautiful code.

This CS concept of "thinking before programming" blends very nicely with
type-driven development. By modelling the problem domain in haskell, we
basically get \emph{typechecked thoughts}!

The \textbf{second stage} is the delivery of a program that already fullfills
some part of the specification, but isn't yet fully complete. During this stage
we'll look at some abstractions and rework some parts of what has been done
(\emph{refactoring is one of Haskell's many great strengths!}). The
\textbf{third stage} is the said complete, polished, program.

Do note that the program should \textbf{compile at all stages}!

\section{ed}\label{sec:ed}

ed is a line-oriented text editor\footnote{from the man page}. It is
used to create, display, modify and otherwise manipulate text files.

If invoked with a \underline{file} argument, then a copy of \underline{file} is
read into the \textbf{editor's buffer}. Changes are made to this copy and not
directly to \underline{file} itself. Upon quitting \textbf{ed}, any changes not
explicitly saved with a @'w'@ command are lost.

Editing is done in two distinct modes: \textbf{command mode} and \textbf{input mode}. When
first invoked, \textbf{ed} is in command mode.

\subsection{Command mode}\label{sec:command}

In this mode commands are read from the standard input and executed to
manipulate the contents of the \textbf{editor buffer}. A typical command might look
like: \underline{@5,12d@} which deletes all lines from line 5 to 12 (including 5 and 12)

All ed commands operate on whole lines or ranges of lines; e.g., the @'d'@
command deletes lines; the @'m'@ command moves lines, and so on.

In general, ed commands consist of zero or more line addresses, followed by a
single character command and possibly additional parameters; i.e., commands
have the structure:

> [address[,address]]command[parameters]

The addresses indicate the line or range of lines to be affected by the
command. An address represents the number of a line in the \textbf{editor
buffer}. The ed utility maintains a \textbf{current address} which is typically supplied
to commands as the default address when none is specified.  When a file is
first read, the \textbf{current address} is set to the last line of the file.

We can run Unix shell (sh) commands from inside \textbf{ed} by prefixing them with @<!>@ (exclamation mark, aka "bang").

\subsection{Input mode}\label{sec:input}

When an input command, such as @'a'@ (append), @'i'@ (insert) or @'c'@
(change), is given, ed enters \textbf{input mode}. This is the primary means of adding
text to a file. In this mode, no commands are available; instead, the standard
input is written directly to the editor buffer. A line consists of the text up
to and including a @<newline>@ character. \textbf{Input mode} is terminated by entering a
single period @('.')@ on a line.

\section{Commands}

All \textbf{ed} commands are single characters, though some require additional
parameters. When nothing is said about unspecified addresses, assume the
\textbf{current address} is passed

\begin{description}

    \item[(.)a] Append text to the \textbf{buffer} after the addressed line. Text is
            entered in \textbf{input mode}. The \textbf{current address} is set to last line entered.

    \item[(.,.)c] Change lines in the \textbf{buffer}. The addressed lines are deleted
            from the buffer, and text is appended in their place. Text is entered in
            \textbf{input mode}. The \textbf{current address} is set to last line entered.

    \item[(.,.)d] Delete the addressed lines from the \textbf{buffer}.  If there is a
            line after the deleted range, then the \textbf{current address} is
            set to this line.  Otherwise the \textbf{current address} is set to
            the line before the deleted range.

    \item[e \underline{file}] Edit \underline{file}, and sets the
            \textbf{default filename}. Any lines in the \textbf{buffer} are deleted before the
            new \underline{file} is read. The \textbf{current address} is set to the last line read.    

    \item[e \underline{!command}] Edit the standard output of \underline{!command}, (see \underline{!command} below).
             The \textbf{default filename} is unchanged.  Any lines in the \textbf{buffer}
             are deleted before the output of \underline{command} is read.  The
             \textbf{current address} is set to the last line read.
             
    \item[f \underline{file}] Set the default filename to \underline{file}.  If
            \underline{file} is not specified, then the \textbf{default filename} is
            printed.
    
    \item[(.)i] Insert text in the \textbf{buffer} before the current line.  Text is
            entered in \textbf{input mode}.  The \textbf{current address} is set to the last
            line entered.

    \item[(.,.)p] Print the addressed lines. The \textbf{current address} is set to the last
            line printed.

    \item[q] Quit \textbf{ed}
    
    \item[r \underline{file}] Read \underline{file} to after the addressed line.  If \underline{file} is not specified,
            then the \textbf{default filename} is used. The \textbf{current address} is set to the last line read.

    \item[r \underline{!command}] Read to after the addressed line the standard output of \underline{!command},
            (see the \underline{!command} below). The \textbf{current address} is set to the last line read.

    %\item[u] Undo the last command and restores the \textbf{current address} to what it
    %         was before the command.

    \item[w \underline{file}] Write the \textbf{edit buffer} to \underline{file}. Any previous contents of \underline{file}
             is lost without warning. If no filename is specified, then the \textbf{default filename} is used.
             The \textbf{current address} is unchanged.

    \item[!command]
             Execute command via \underline{sh}. When
             the shell returns from execution, a ‘!’ is printed to the standard
             output.  The \textbf{current line} is unchanged.

\end{description}

\section{Project}

Write a program that implements the features of this simplified \textbf{ed}
clone. The program should always receive an argument indicating the name of the
file to edit, start in \textbf{command mode}, and receive user input from the
standard input (which might be a command when in command mode and just text
when in input mode). The commands that must be implemented are listed under the
\textbf{commands} section. Both the \textbf{command mode} and \textbf{input
mode} should behave as described in the corresponding section. In general, the
program should behave as the described line editor -- the first part of the
assignment is processing "ed line editor" from idea into program.

This program should be delivered in the stages mentioned above, but do
ask questions at any time -- we'll iterate on your work \emph{during} the stages.
The program should be version controlled and pushed to a remote repository.

Get started by answering these design questions:

\begin{itemize}
    \item How would you model the \textbf{editor buffer}? The buffer keeps the text being
    edited, and the edited text content is flushed to a file with the @'w'@ command.

    \item The program will receive one line from the user at a time. What would be the
    type signature of a function that \emph{processes} an input string from the
    user? Hint: When editing, we can be either in \textbf{command mode} or in
    \textbf{input mode}. Therefore the user input can be either of two things: a
    text line to input in the buffer, or a command. To determine whether the user
    input should be parsed as either a line or a comand, the function will have to
    depenend on the current \textbf{mode}.

    \item What would be the type signature of a function that executes a user
    given command? Remember that some commands might change the editor \textbf{mode}.

    \item What would be the signature of a function that adds the text given by the user
    to the \textbf{editor buffer}? The \textbf{mode} changes back to command when a
    @'.'@ on a single line is inputted.
\end{itemize}

Note that the execute command and input text functions work on a current buffer and a current line.

\end{document}
