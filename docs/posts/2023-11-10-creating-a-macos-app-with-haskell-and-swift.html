<!doctype html>
<html lang="en">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Creating a macOS app with Haskell and Swift</title>
    
    <meta name="description" content="First part of an in-depth guide into developing a native macOS application using Haskell with Swift and SwiftUI. This part covers the set-up required to call Haskell functions from Swift in an XCode project using SwiftUI.">
    
    <link rel="stylesheet" href="../css/default.css" />
    <link rel="stylesheet" href="../css/clay.css" />
    <link rel="stylesheet" href="../css/syntax.css" />

    <!-- open graph -->
    <meta property="og:title" content="Creating a macOS app with Haskell and Swift" />
    
    <meta property="og:description" content="First part of an in-depth guide into developing a native macOS application using Haskell with Swift and SwiftUI. This part covers the set-up required to call Haskell functions from Swift in an XCode project using SwiftUI." />
    

    
    
    

    <!-- favicon -->
    <link rel="apple-touch-icon" sizes="180x180" href="../apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
    <link rel="manifest" href="../site.webmanifest">

    <script defer data-domain="alt-romes.github.io" src="https://plausible.io/js/script.js"></script>
  </head>
  <body>
    <nav>
      <ul>
        <li class="logo"><a href="../">romes</a></li>
        <li><a href="../posts.html">blog</a></li>
        <li>music</li>
        <!-- <li><a href="/papers.html">publications</a></li> -->
        <li>publications</li>
        <li class="hidden-small"><a href="https://github.com/alt-romes" target="_blank">github</a></li>
        <li class="hidden-small"><a href="https://gitlab.haskell.org/alt-romes" target="_blank">ghc</a></li>
      </ul>
    </nav>
    <main>
      <header>
  <div class="title">
    <h1>Creating a macOS app with Haskell and Swift</h1>
    <p>
      
      Nov 10, 2023
      
    </p>
  </div>
  
  <p class="description">First part of an in-depth guide into developing a native macOS application using Haskell with Swift and SwiftUI. This part covers the set-up required to call Haskell functions from Swift in an XCode project using SwiftUI.</p>
  
  
  <ul class="tags">
    <li class="tag-haskell">#<a href="../tags/haskell.html">haskell</a></li><li class="tag-swift">#<a href="../tags/swift.html">swift</a></li><li class="tag-macos">#<a href="../tags/macos.html">macos</a></li>
  </ul>
  
</header>


<article>
  <div class="toc"><div class="header">Contents</div>
<ul>
<li><a href="#hello-swift-its-haskell" id="toc-hello-swift-its-haskell"><span class="toc-section-number">1</span> Hello, Swift, it’s Haskell!</a>
<ul>
<li><a href="#setting-up-the-swiftui-app" id="toc-setting-up-the-swiftui-app"><span class="toc-section-number">1.1</span> Setting up the SwiftUI app</a></li>
<li><a href="#setting-up-a-haskell-foreign-library" id="toc-setting-up-a-haskell-foreign-library"><span class="toc-section-number">1.2</span> Setting up a Haskell foreign library</a></li>
<li><a href="#linking-the-haskell-library-with-the-executable" id="toc-linking-the-haskell-library-with-the-executable"><span class="toc-section-number">1.3</span> Linking the Haskell library with the executable</a></li>
<li><a href="#the-rts-must-be-initialized" id="toc-the-rts-must-be-initialized"><span class="toc-section-number">1.4</span> The RTS must be initialized</a></li>
</ul></li>
<li><a href="#remarks" id="toc-remarks"><span class="toc-section-number">2</span> Remarks</a>
<ul>
<li><a href="#further-reading" id="toc-further-reading"><span class="toc-section-number">2.1</span> Further Reading</a></li>
</ul></li>
</ul>
</div>
<p>This is the first part of an in-depth guide into developing a native
applications for Apple platforms (macOS, iOS, etc.) using Haskell with Swift and
SwiftUI. This is the first in a series of blog posts – covering the set-up
required to call Haskell functions from Swift in an XCode project using SwiftUI.
In future installements of the series, I intend to at least discuss calling
functions with idiomatic Haskell types with Swift ones (both with and without
marshaling), SwiftUI observation, and iOS development which requires GHC to
produce code for the iOS compilation target.</p>
<p>At the time of writing I’m using XCode 15, Cabal 3.10, and GHC 9.8. There will
be some features I use that are only available in these recent versions,
however, the general idea of interoperability between Haskell and Swift stands
on its own regardless – the now 7 year
old <a href="https://github.com/nanotech/swift-haskell-tutorial/tree/master">swift-haskell-tutorial</a> is still similarly relevant and greatly informed
my approach, despite the end result being considerably different.</p>
<p>The end goal is to create a multi-(apple)-platform application whose UI is
programmed in Swift using SwiftUI while the data and logic of the application is
implemented in Haskell which is called from Swift.</p>
<p>The series of blog posts is further accompanied by a github repository where
each commit matches a step of this tutorial. If in doubt regarding any step,
simply checking the matching commit for absolute confidence you are
understanding the practical step correctly. <a href="https://github.com/alt-romes/haskell-x-swift-project-steps">Visit this link to the haskell-x-swift-project-steps repository</a>!
Furthermore, I’m writing a build tool that will facilitate setting up and
building a project like this without having to go through all the manual steps: <a href="https://github.com/alt-romes/haskell-swift">haskell-swift</a>.</p>
<p>This write-up has been cross-posted to <a href="https://well-typed.com/blog/">Well-Typed’s Blog</a>.</p>
<h1 data-number="1" id="hello-swift-its-haskell"><span class="header-section-number">1</span> Hello, Swift, it’s Haskell!</h1>
<p>In this part we are only concerned with getting our <code>Hello, World!</code> going.</p>
<ol type="1">
<li>We’ll setup a Haskell (foreign) library exporting a function <code>hs_factorial</code> that
returns the factorial of integer, using the C FFI</li>
<li>Setup a SwiftUI app that calls <code>hs_factorial</code></li>
<li>Compile the Haskell code into a shared library</li>
<li>Create a Swift module <code>HaskellFramework</code> to export the Haskell functions
(imported from the stub C header files), and setup linking against the
Haskell shared library.</li>
<li>Import <code>HaskellFramework</code> into the SwiftUI app to be able to successfully
call <code>hs_factorial</code> and display the result on the screen of the running
application.</li>
</ol>
<p>The following diagram (rendered by <a href="https://arthursonzogni.com/Diagon/#GraphDAG">Diagon</a>) describes how the Swift executable and Haskell libraries
are going to be connected from a not-too-far-away perspective. It might be
useful to consult this diagram once in a while throughout the post!
<!-- Source code of graph @ https://arthursonzogni.com/Diagon/#GraphDAG

Haskell library -> Haskell foreign library
cbits -> Haskell foreign library
cbits -> Headers (cbits)
Haskell foreign library -> Headers (stubs)
Haskell foreign library -> Shared dynamic library
Headers (stubs) -> Clang modules
Headers (cbits) -> Clang modules

gen-dynamic-settings.sh -> DynamicBuildSettings.xcconfig
RTS headers -> DynamicBuildSettings.xcconfig
Shared dynamic library -> DynamicBuildSettings.xcconfig
DynamicBuildSettings.xcconfig -> BuildSettings.xcconfig

Clang modules -> SwiftUI App
Shared dynamic library -> SwiftUI App
BuildSettings.xcconfig -> SwiftUI App
--></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>┌───────────────┐┌───────────┐┌───────────────────────┐┌───────────┐</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>│Haskell library││cbits      ││gen-dynamic-settings.sh││RTS headers│</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>└┬──────────────┘└┬─────────┬┘└─────────────┬─────────┘└┬──────────┘</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>┌▽────────────────▽───────┐┌▽──────────────┐│           │</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>│Haskell foreign library  ││Headers (cbits)││           │</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>└┬───────────────────────┬┘└─────────────┬─┘│           │</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>┌▽─────────────────────┐┌▽──────────────┐│  │           │</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>│Shared dynamic library││Headers (stubs)││  │           │</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>└┬────────────────────┬┘└┬──────────────┘│  │           │</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a> │            ┌───────│──│───────────────┘  │           │</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a> │            │┌──────│──┘                  │ ┌─────────┘</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a> │┌───────────▽▽┐┌────▽─────────────────────▽─▽┐</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a> ││Clang modules││DynamicBuildSettings.xcconfig│</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a> │└┬────────────┘└┬────────────────────────────┘</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a> │ │┌─────────────▽────────┐</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a> │ ││BuildSettings.xcconfig│</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a> │ │└┬─────────────────────┘</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>┌▽─▽─▽──────┐</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>│SwiftUI App│</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>└───────────┘</span></code></pre></div>
<h2 data-number="1.1" id="setting-up-the-swiftui-app"><span class="header-section-number">1.1</span> Setting up the SwiftUI app</h2>
<p>Let’s set-up a simple XCode project using SwiftUI for the main interface. Fire
up XCode and create a macOS Application, named <code>SwiftHaskell</code>, using SwiftUI,
excluding tests. Choose a Personal Team rather than None - you might have to
create a (free of charge) one.</p>
<p>In the newly-created project there should exist two files: <code>SwiftHaskellApp.swift</code> and <code>ContentView.swift</code>.
We can change right away <code>ContentView.swift</code> to display the result of calling
<code>hs_factorial(5)</code>, even though <code>hs_factorial</code> is not yet in scope:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode swift"><code class="sourceCode swift"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="im">SwiftUI</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> ContentView<span class="op">:</span> <span class="dt">View</span> <span class="op">{</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">var</span> <span class="va">body</span><span class="op">:</span> some View <span class="op">{</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>        VStack <span class="op">{</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>            Text<span class="op">(</span><span class="st">&quot;Hello, Haskell: </span><span class="er">\(</span><span class="st">hs_factorial(5))!&quot;</span><span class="op">)</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>padding<span class="op">()</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Before proceeding to the Haskell side, create a <code>New File &gt; Configuration Settings File</code> (also known as a <code>.xcconfig</code> file) named
<code>BuildSettings.xcconfig</code>. We’ll use this file to write all our build settings
textually instead of using XCode’s build settings navigator.</p>
<p>To use our <code>.xcconfig</code> file for the project settings, under <code>Info &gt; Configurations</code>
in the project tab, select the <code>BuildSettings</code> file.
For the configuration to show up in XCode, the <code>.xcconfig</code> must be in the tree
navigator (which happens by default if you created the module within XCode).
You can read more, or see exactly how to set an <code>.xcconfig</code> file as the
configuration, in this <a href="https://nshipster.com/xcconfig/">write-up on <code>xcconfig</code></a>
by NSHipster.</p>
<p>Even though we are setting the <code>.xcconfig</code> file manually (and also e.g.
initializing the XCode project), it is possible to resort to an exclusively
programatic approach using so-called XCode project generators such as
<a href="https://github.com/yonaskolb/XcodeGen">XCodeGen</a>
and <a href="https://tuist.io/">Tuist</a>.</p>
<h2 data-number="1.2" id="setting-up-a-haskell-foreign-library"><span class="header-section-number">1.2</span> Setting up a Haskell foreign library</h2>
<p>Create a folder <code>haskell-framework</code> within the XCode project, <code>cd</code> into it, and
follow from there.</p>
<p>We’re jumping straight into a full-fledged Haskell projected managed with cabal,
where we define a shared library using the <code>foreign-library</code> stanza.</p>
<p>Start with a normal cabal file with a <code>library</code> stanza that exposes <code>MyLib</code> (by
running <code>cabal init</code> within <code>haskell-framework</code>), and add the function <code>hs_factorial</code> to <code>MyLib</code> that
operates on <code>CInt</code>s:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">MyLib</span> <span class="kw">where</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Foreign.C</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="ot">hs_factorial ::</span> <span class="dt">CInt</span> <span class="ot">-&gt;</span> <span class="dt">CInt</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>hs_factorial x <span class="ot">=</span> <span class="fu">product</span> [<span class="dv">1</span><span class="op">..</span>x]</span></code></pre></div>
<p>The organization of the code here isn’t terribly important. Perhaps in a
real project you could want to, for instance, only use C types like <code>CInt</code>
in the foreign library bits.</p>
<p>In the cabal file, add a <code>foreign-library</code> stanza with</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>foreign<span class="op">-</span>library haskell<span class="op">-</span>foreign<span class="op">-</span>framework</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span><span class="op">:</span> native<span class="op">-</span>shared</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- This should work on Mac, despite being undefined behaviour</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- See https://www.hobson.space/posts/haskell-foreign-library/ (great read)</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    options<span class="op">:</span> standalone</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- We copy the C stub headers to a folder in the root.</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- If you have foreign-export declarations in the library</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- be sure to add this flag there too (so all stubs get added</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- to the `haskell-framework-include` folder)</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    ghc<span class="op">-</span>options<span class="op">:</span> <span class="op">-</span>stubdir<span class="ot">=</span>haskell<span class="op">-</span>framework<span class="op">-</span>include</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>    other<span class="op">-</span>modules<span class="op">:</span> <span class="dt">MyForeignLib</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>    build<span class="op">-</span>depends<span class="op">:</span> base, haskell<span class="op">-</span>framework</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>    hs<span class="op">-</span>source<span class="op">-</span>dirs<span class="op">:</span> flib</span></code></pre></div>
<p>Unfortunately, <code>options: standalone</code> is only officially supported (and
required) by Windows, even though it is exactly what we need. However,
unofficially, a macOS distribution should be able to safely use this option
– for more information see this <a href="https://www.hobson.space/posts/haskell-foreign-library/">write-up on foreign libraries explaining why this option is
undefined for macOS</a>.
<!---->
In the future, this might work out of the box without being undefined
behaviour, or the behaviour on macOS may have changed s.t. this no longer
works… but let’s hope for the former.
<!---->
Additionally, we pass <code>-stubdir</code> for GHC to output the C stub header files to a
directory <code>haskell-framework-include</code>. Do add this automatically generated
directory to <code>.gitignore</code>.</p>
<p>Create the file <code>flib/MyForeignLib.hs</code> that declares a <code>foreign export</code> of
<code>hs_factorial</code> imported from <code>MyLib</code> and <code>foreign export</code>s it:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ForeignFunctionInterface #-}</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">MyForeignLib</span> <span class="kw">where</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Foreign.C</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">MyLib</span> (hs_factorial)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>foreign export ccall<span class="ot"> hs_factorial ::</span> <span class="dt">CInt</span> <span class="ot">-&gt;</span> <span class="dt">CInt</span></span></code></pre></div>
<p>It doesn’t seem that re-exporting the function from <code>MyLib</code> when it is foreign
exported from there is enough for it to be included in the shared library (might
be a bug), we do need the <code>foreign export</code> here rather than in <code>MyLib</code>.</p>
<p>Running <code>cabal build</code> should now generate a <code>haskell-framework-include</code> folder with a
<code>MyForeignLib_stub.h</code>, and a <code>libhaskell-foreign-framework.dylib</code> shared library
somewhere under <code>dist-newstyle</code> (you can <code>find . -name libhaskell-foreign-framework.dylib</code> to find it)</p>
<p>We’ll test C program against this library to check whether it works as expected.
Create <code>scripts/test-haskell-foreign-lib.sh</code> with a script that compiles a
main function in C which calls <code>hs_factorial</code>. A few notes:</p>
<ul>
<li>We need to pass the path to the built shared library (<code>$HS_FLIB_PATH</code>)
to the compiler.</li>
<li>We need to pass the path to the headers (<code>$HS_HEADERS_PATH</code>).</li>
<li>We hardcode into the executable the path to the shared library as an <code>rpath</code>
search path (just for testing purposes).
When building the macOS app, XCode will add <code>@executable_path/../Frameworks</code>
to the <code>rpath</code> search path, so we can simply copy the shared library the
Apple-blessed location (<code>Frameworks</code>).</li>
<li>We need to call <code>hs_init</code> and <code>hs_exit</code> to init the runtime system
(see the <a href="https://downloads.haskell.org/ghc/latest/docs/users_guide/exts/ffi.html#using-the-ffi-with-ghc">relevant GHC user guide section</a>).</li>
<li>We need to compile the C library using <code>ghc</code>, as it will automatically
include and link the rts headers and library. To use a C compiler
we’d also need to find the rts headers and library of our Haskell
installation.</li>
</ul>
<div class="sourceCode" id="cb6"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co">#!/usr/bin/env bash</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="bu">set</span> <span class="at">-e</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="ot">! </span><span class="bu">test</span> <span class="at">-f</span> <span class="st">&quot;haskell-framework.cabal&quot;</span><span class="kw">;</span> <span class="cf">then</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">echo</span> <span class="st">&quot;Run this script from the root of your project!&quot;</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">exit</span> 1</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="cf">fi</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a><span class="va">HS_FLIB_PATH</span><span class="op">=</span><span class="va">$(</span><span class="fu">dirname</span> <span class="va">$(</span><span class="fu">find</span> . <span class="at">-name</span> libhaskell-foreign-framework.dylib<span class="va">))</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="va">HS_HEADERS_PATH</span><span class="op">=</span>haskell-framework-include</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a><span class="bu">echo</span> <span class="st">&quot;</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a><span class="st">#include &lt;stdio.h&gt;</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a><span class="st">#include &lt;MyForeignLib_stub.h&gt;</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a><span class="st">#include &lt;HsFFI.h&gt;</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a><span class="st">int main(void) {</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a><span class="st">    hs_init(NULL, NULL);</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a><span class="st">    printf(</span><span class="dt">\&quot;</span><span class="st">%d\n</span><span class="dt">\&quot;</span><span class="st">, hs_factorial(5));</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a><span class="st">    hs_exit();</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a><span class="st">    return 0;</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a><span class="st">}</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;</span> <span class="op">&gt;</span> conftestmain.c</span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a><span class="co"># We use `ghc` instead of `gcc` because otherwise we also need to provide the</span></span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a><span class="co"># include and lib path of the runtime system (Rts)</span></span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a><span class="ex">ghc</span> <span class="at">-no-hs-main</span> <span class="at">-o</span> conftest conftestmain.c <span class="dt">\</span></span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>    <span class="at">-lhaskell-foreign-framework</span> <span class="dt">\</span></span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a>    <span class="at">-I</span><span class="st">&quot;</span><span class="va">$HS_HEADERS_PATH</span><span class="st">&quot;</span> <span class="dt">\</span></span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a>    <span class="at">-L</span><span class="st">&quot;</span><span class="va">$HS_FLIB_PATH</span><span class="st">&quot;</span> <span class="dt">\</span></span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a>    <span class="at">-optl-Wl,-rpath,</span><span class="st">&quot;</span><span class="va">$HS_FLIB_PATH</span><span class="st">&quot;</span></span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a><span class="va">RESULT</span><span class="op">=</span><span class="va">$(</span><span class="ex">./conftest</span><span class="va">)</span></span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="bu">[</span> 120 <span class="ot">-eq</span> <span class="va">$RESULT</span> <span class="bu">]</span><span class="kw">;</span> <span class="cf">then</span></span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true" tabindex="-1"></a>    <span class="bu">echo</span> <span class="st">&quot;Foreign library successfully called!&quot;</span></span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span></span>
<span id="cb6-38"><a href="#cb6-38" aria-hidden="true" tabindex="-1"></a>    <span class="bu">echo</span> <span class="st">&quot;Bad bad foreign library!&quot;</span></span>
<span id="cb6-39"><a href="#cb6-39" aria-hidden="true" tabindex="-1"></a>    <span class="bu">exit</span> 1</span>
<span id="cb6-40"><a href="#cb6-40" aria-hidden="true" tabindex="-1"></a><span class="cf">fi</span></span>
<span id="cb6-41"><a href="#cb6-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-42"><a href="#cb6-42" aria-hidden="true" tabindex="-1"></a><span class="fu">rm</span> <span class="at">-f</span> conftest<span class="pp">*</span></span></code></pre></div>
<p>You should get <code>Foreign library successfully called!</code> when this script is run.</p>
<h2 data-number="1.3" id="linking-the-haskell-library-with-the-executable"><span class="header-section-number">1.3</span> Linking the Haskell library with the executable</h2>
<p>Our recipe for invoking a foreign exported Haskell function in Swift:</p>
<ol type="1">
<li>Create a Swift <em>module</em> exporting Haskell functions through a module map
pointing to the headers exporting the Haskell functions.</li>
<li>Extend the <em>module search path</em> with the location of your new module map.</li>
<li>Import that module as a module in the SwiftUI code, and use the desired function.</li>
<li>At link time, the shared library with the symbols used by the program must be
linked against, and must be found in the <em>run-path</em> which can be done by copying
the shared library into the app bundled <code>Frameworks</code> folder.</li>
</ol>
<p>We create a module map file listing all the headers exporting Haskell functions
to define Swift modules where Haskell functions will live, using <a href="https://clang.llvm.org/docs/Modules.html">Clang’s module
system</a>. A module map looks something like</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">HaskellFramework</span> {</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    header <span class="st">&quot;haskell-framework/haskell-framework-include/MyForeignLib.h&quot;</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    export <span class="op">*</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>and can be imported into Swift code with <code>import HaskellFramework</code>, as long as
the module map is available as <code>module.modulemap</code> in the <em>import search path</em>.
As one might expect, importing this module brings into scope all names exported
from the listed header(s).</p>
<p>Specifically, we will use the <a href="https://clang.llvm.org/docs/Modules.html#submodule-declaration">inferred submodules</a>
feature of modules to create our module map. With inferred submodules, we can
simply define an <strong>umbrella</strong> directory with headers and get a submodule for each
header in that directory (arbitrarily nested, where a header <code>A/B/C.h</code> becomes a
submodule named <code>MainModule.A.B.C</code>)</p>
<p>In the root of the XCode project, write a <code>module.modulemap</code> file:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">HaskellFramework</span> {</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    umbrella <span class="st">&quot;haskell-framework/haskell-framework-include&quot;</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    explicit <span class="kw">module</span> <span class="op">*</span> {</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>        export <span class="op">*</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>The <code>umbrella</code> keyword specifies the directory where to find the header files
for our submodules, and the <code>explicit module *</code> lines are the <em>inferred
submodule</em> part, as each header will result in a declaration roughly like
<code>explicit module HeaderName { header "umbrella/HeaderName.h" ... }</code>.
In effect, our module map above will expand to:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">HaskellFramework</span> {</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    explicit <span class="kw">module</span> <span class="dt">MyForeignLib</span> {</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>        header <span class="st">&quot;haskell-framework/haskell-framework-include/MyForeignLib.h&quot;</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>        export <span class="op">*</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Again, to be clear, this is what our original <code>module.modulemap</code> using the
<code>umbrella</code> keyword currently expands to, <strong>not the file we wrote</strong>.</p>
<p>Having written our <code>module.modulemap</code>, we need to extend the compiler’s <em>import
search path</em> to find this module map. As we’ve already set-up our <code>xcconfig</code>-based
configuration, this amounts to writing into <code>BuildSettings.xcconfig</code>:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="va">SWIFT_INCLUDE_PATHS</span><span class="op">=</span><span class="va">$(</span><span class="ex">PROJECT_DIR</span><span class="va">)</span></span></code></pre></div>
<p>This is equivalent to changing the <code>Swift Compiler - Search Paths &gt; Import Paths</code> build setting in XCode (in fact, by inspecting that setting on the
rightmost inspector panel, you will find the corresponding <code>xcconfig</code> name is indeed
<code>SWIFT_INCLUDE_PATHS</code> – this is also all explained in the <a href="https://nshipster.com/xcconfig/"><code>xcconfig</code>
article</a>).</p>
<p>Returning to <code>ContentView.swift</code>, where <code>hs_factorial</code> is being called, you
should be able to add at the top of the file, and have XCode successfully recognize:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode swift"><code class="sourceCode swift"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="im">HaskellFramework</span><span class="op">.</span><span class="im">MyForeignLib_stub</span></span></code></pre></div>
<p>Even though the import is recognized, it will not compile successfully. The
reason is our stub header (<code>MyForeignLib_stub.h</code>) includes <code>&lt;HsFFI.h&gt;</code> which
cannot be found by XCode. We need to extend our <em>Header Search Path</em> with the
path to the RTS headers.</p>
<p>Currently, our <code>BuildSettings.xcconfig</code> can only contain statically known
information. Fortunately, we can <code>#include</code> other <code>xcconfig</code> files (that may
have been generated dynamically) in our <code>BuildSettings.xcconfig</code> (as described
by the <a href="https://nshipster.com/xcconfig/"><code>xcconfig</code> write-up</a>).
We do this by adding the following include directive in the <code>BuildSettings.xcconfig</code> file:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;DynamicBuildSettings.xcconfig&quot;</span></span></code></pre></div>
<p>We will generate <code>DynamicBuildSettings.xcconfig</code> with a script
<code>haskell-framework/scripts/gen-dynamic-settings.sh</code> that calls the</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ex">ghc-pkg</span> field rts include-dirs <span class="at">--simple-output</span></span></code></pre></div>
<p>to figure out the rts include path of the existing GHC installation.</p>
<p>We extend <code>HEADER_SEARCH_PATHS</code>, the <code>xcconfig</code> variable listing the paths where
XCode will search for headers when building, with the path to the RTS header
files:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co">#!/usr/bin/env bash</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="bu">set</span> <span class="at">-e</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="ot">! </span><span class="bu">test</span> <span class="at">-f</span> <span class="st">&quot;haskell-framework/haskell-framework.cabal&quot;</span><span class="kw">;</span> <span class="cf">then</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">echo</span> <span class="st">&quot;Run this script from the root of your XCode project!&quot;</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">exit</span> 1</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a><span class="cf">fi</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a><span class="bu">echo</span> <span class="st">&quot;</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a><span class="st">HEADER_SEARCH_PATHS=</span><span class="dt">\$</span><span class="st">(inherit) </span><span class="va">$(</span><span class="ex">ghc-pkg</span> field rts include-dirs <span class="at">--simple-output</span> <span class="kw">|</span> <span class="fu">tr</span> <span class="st">' '</span> <span class="st">'\n'</span> <span class="kw">|</span> <span class="fu">tail</span> <span class="at">-n1</span><span class="va">)</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;</span> <span class="op">&gt;</span> DynamicBuildSettings.xcconfig</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a><span class="bu">echo</span> <span class="st">&quot;Created DynamicBuildSettings.xcconfig!&quot;</span></span></code></pre></div>
<p>Do add <code>DynamicBuildSettings.xcconfig</code> to <code>.gitignore</code>.
The literal string <code>$(inherit)</code> is <code>xcconfig</code> syntax for inheriting the options
set before applying this configuration. Furthermore,
asking for the <code>include-dirs</code> of <code>rts</code> outputs two directories:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/ffi</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>/Users/romes/.ghcup/ghc/9.8.1/lib/ghc-9.8.1/lib/../lib/aarch64-osx-ghc-9.8.1/rts-1.0.2/include</span></code></pre></div>
<p>However, the <code>ffi</code> header is already included in a module by default in XCode
applications, so we need to cut it out of the search paths to avoid a
<code>Redefinition of module 'FFI'</code> error (<code>tr</code> combined with <code>tail -n1</code> select just
the path to the RTS headers).</p>
<p>The function is now found by XCode as the module it is defined in compiles
successfully and brings the function into scope.
However, building the program will fail with a <em>link time</em> error:
even though we instructed the compiler to find the definitions of the Haskell
functions we want to use and the module they are exported from, we have not
linked against the library where the actual symbols are defined.</p>
<p>The Haskell foreign library created in a previous section compiles to a
<em>shared dynamic library</em>. To link against it when building our Swift application
we need to pass <code>-lhaskell-foreign-framework</code> to the compilation toolchain and
instruct it on where to find this library. The first step can be done in two
compatible (as in both can co-exist) ways:</p>
<ul>
<li>Add a <code>link "haskell-foreign-framework"</code> declaration to the module map (explained <a href="https://clang.llvm.org/docs/Modules.html#link-declaration">here</a>)
<ul>
<li>There is a note about this feature not yet being widely supported in the
reference page, however, it is works to link the library in my machine
with XCode 15.</li>
</ul></li>
<li>Add the <code>-lhaskell-foreign-framework</code> flag to the <code>OTHER_LDFLAGS</code> build
setting in <code>BuildSettings.xcconfig</code>. You can do this even if you’ve also
used the link directive.</li>
</ul>
<p>After adding the <code>link</code> declaration, your <code>module.modulemap</code> should contain:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">HaskellFramework</span> {</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    umbrella <span class="st">&quot;haskell-framework/haskell-framework-include&quot;</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    explicit <span class="kw">module</span> <span class="op">*</span> {</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>        export <span class="op">*</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>    link <span class="st">&quot;haskell-foreign-framework&quot;</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Secondly, we need to add the shared library path to the <em>library search path</em>
and make it available at runtime by copying it to the <code>Frameworks</code> folder that
is bundled with the application.
By copying the library to this folder we ensure it can be found when dynamically
loaded at runtime: the library install name is relative to <code>@rpath</code>, i.e. it is
a <a href="https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/DynamicLibraries/100-Articles/RunpathDependentLibraries.html"><em>run-path dependent library</em></a>,
and the run-path dependencies of XCode built executables are searched for in the
Frameworks folder, relatively to the executable path (<code>@executable_path/../Frameworks</code>).</p>
<blockquote>
<p>A run-path dependent library is a dependent library whose complete install
name is not known when the library is created (see How Dynamic Libraries Are
Used). Instead, the library specifies that the dynamic loader must resolve the
library’s install name when it loads the executable that depends on the
library.</p>
<p>To use run-path dependent libraries, an executable provides a list of run-path
search paths, which the dynamic loader traverses at load time to find the
libraries.</p>
</blockquote>
<p>In practice, we achieve this by extending the <code>LIBRARY_SEARCH_PATHS</code> setting
dynamically and add a “Copy” Build Phase which copies the shared library to the
listed Frameworks folder. At this time, I do not know how to do this Copy
outside of XCode – do shoot me a text if you know how. It is also unfortunate
that we have to hardcode the path to the dynamic library there, instead of
computing it at build time.</p>
<p>Find the path to the foreign library by running, in the <code>haskell-framework</code> directory:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>cabal list-bin haskell-foreign-framework</span></code></pre></div>
<p>Then, under the Build Phases tab of the project settings, add (by clicking in
the little plus sign) a <code>New Copy Files Phase</code>. Then, clicking in the plus sign of
the new listing of files to copy, add the haskell-foreign-framework
<code>.dylib</code> (the shared library) that lives at the path found by running the above
command by clicking on “Add Other”.</p>
<p>To the <code>haskell-framework/scripts/gen-dynamic-settings.sh</code>, add the following
lines before echoing to the file</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="bu">pushd</span> . <span class="op">&gt;</span> /dev/null</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="bu">cd</span> haskell-framework</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="va">FLIB_PATH</span><span class="op">=</span><span class="va">$(</span><span class="ex">cabal</span> list-bin haskell-foreign-framework<span class="va">)</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="bu">popd</span> <span class="op">&gt;</span> /dev/null</span></code></pre></div>
<p>and to what is written to <code>DynamicBuildSettings.xcconfig</code> add the following line</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="va">LIBRARY_SEARCH_PATHS</span><span class="op">=</span><span class="dt">\$</span><span class="kw">(</span><span class="ex">inherit</span><span class="kw">)</span> <span class="va">$(</span><span class="fu">dirname</span> <span class="va">$FLIB_PATH)</span></span></code></pre></div>
<p>At this point, after regenerating the dynamic build settings, you should be able
to link the application successfully, and run it.</p>
<h2 data-number="1.4" id="the-rts-must-be-initialized"><span class="header-section-number">1.4</span> The RTS must be initialized</h2>
<p>Surprise! Running the application will fail at runtime, when <code>hs_factorial</code> is
called. To call Haskell functions from an executable written in another language,
one must first initialize the GHC runtime system, and terminate it when
appropriate. We need to call the functions <code>hs_init</code> and <code>hs_end</code>, exposed in
<code>HsFFI.h</code>. We will write two wrapper functions in our foreign library to invoke
instead, as suggested in the <a href="https://downloads.haskell.org/ghc/latest/docs/users_guide/exts/ffi.html#using-the-ffi-with-ghc">FFI chapter of the GHC user guide</a>.</p>
<p>We create a <code>cbits</code> folder in the <code>haskell-framework</code> Haskell project to put our
C files and headers, and add them to the <code>foreign-library</code> stanza of the cabal
file:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>include<span class="op">-</span>dirs<span class="op">:</span> cbits</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>c<span class="op">-</span>sources<span class="op">:</span> cbits<span class="op">/</span>MyForeignLibRts.c</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>install<span class="op">-</span>includes<span class="op">:</span> MyForeignLibRts.h</span></code></pre></div>
<p>You can see what these options do in <a href="https://cabal.readthedocs.io/en/stable/cabal-package.html#pkg-field-includes">this cabal user guide section</a>.
We create <code>cbits/MyForeignLibRts.c</code> wrapping the calls to <code>hs_init</code> and
<code>hs_end</code> as described in the FFI chapter linked above:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;HsFFI.h&gt;</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>HsBool flib_init<span class="op">()</span> <span class="op">{</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Initialising flib</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Initialise Haskell runtime</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>    hs_init<span class="op">(</span>NULL<span class="op">,</span> NULL<span class="op">);</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Do other library initialisations here</span></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> HS_BOOL_TRUE<span class="op">;</span></span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> flib_end<span class="op">()</span> <span class="op">{</span></span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Terminating flib</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a>    hs_exit<span class="op">();</span></span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>It might seem that you could <code>foreign import</code> these functions into the Haskell
library and re-export them with <code>foreign export</code>, however, if they are exported
from Haskell, they themselves require the RTS to be initialised, effectively
defeating the purpose of being functions that initialise the RTS. Therefore, we
write a header file that we ship with the library for it to be included by the
Swift project. The file <code>cbits/MyForeignLibRts.h</code> contains:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;HsFFI.h&gt;</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>HsBool flib_init<span class="op">();</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> flib_end<span class="op">();</span></span></code></pre></div>
<p>Back to the Swift side, we need to augment our module map with a module mapping
to the RTS initialisation wrapper header. We add a second submodule declaration:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>explicit <span class="kw">module</span> <span class="dt">RTSManage</span> {</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>   header <span class="st">&quot;haskell-framework/cbits/MyForeignLibRts.h&quot;</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>The <code>cbits/MyForeignLibRts.c</code> symbols will be included in the shared dynamic
library.</p>
<p>You can re-buid the haskell library and re-generate the dynamic settings with a
script <code>./build-haskell</code> in the root of the XCode project:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="co">#!/usr/bin/env bash</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="bu">set</span> <span class="at">-e</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="ot">! </span><span class="bu">test</span> <span class="at">-d</span> <span class="st">&quot;SwiftHaskell.xcodeproj&quot;</span><span class="kw">;</span> <span class="cf">then</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">echo</span> <span class="st">&quot;Run this from the SwiftHaskell XCode project root!&quot;</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">exit</span> 1</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a><span class="cf">fi</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a><span class="bu">pushd</span> . <span class="op">&gt;</span>/dev/null</span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a><span class="bu">cd</span> haskell-framework/</span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a><span class="ex">cabal</span> build all <span class="at">--allow-newer</span></span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a><span class="ex">./scripts/test-haskell-foreign-lib.sh</span></span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a><span class="bu">popd</span> <span class="op">&gt;</span>/dev/null</span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true" tabindex="-1"></a><span class="ex">./haskell-framework/scripts/gen-dynamic-settings.sh</span></span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true" tabindex="-1"></a><span class="bu">echo</span> <span class="st">&quot;Done.&quot;</span></span>
<span id="cb24-18"><a href="#cb24-18" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
<p>Finally, in <code>SwiftHaskellApp.swift</code>, we extend the <code>@main</code> <code>App</code> by overriding
the <code>init()</code> function: calling <code>flib_init()</code> to initialise the runtime system
and setting up an observer to call <code>flib_end()</code> to end the runtime system when
the application terminates. We need only import <code>HaskellFramework.RTSManage</code> to
bring these functions into scope:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode swift"><code class="sourceCode swift"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="at">@main</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> SwiftHaskellApp<span class="op">:</span> <span class="dt">App</span> <span class="op">{</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">init</span><span class="op">()</span> <span class="op">{</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>        flib_init<span class="op">()</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>        NotificationCenter<span class="op">.</span><span class="kw">default</span><span class="op">.</span>addObserver<span class="op">(</span>forName<span class="op">:</span> NSApplication<span class="op">.</span>willTerminateNotification<span class="op">,</span> object<span class="op">:</span> <span class="kw">nil</span><span class="op">,</span> queue<span class="op">:</span> <span class="op">.</span>main<span class="op">)</span> <span class="op">{</span> _ <span class="cf">in</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>            <span class="co">// terminating</span></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>            flib_end<span class="op">()</span></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Running your application should work and proudly print <code>120</code> on the screen.</p>
<h1 data-number="2" id="remarks"><span class="header-section-number">2</span> Remarks</h1>
<p>We’ve come to the end of the first installment in this blogpost series.
Next up is communicating more interesting data types (both with and without
marshalling), making things more ergonomic to use, SwiftUI observation, iOS
compilation, and perhaps developing a simple model app.</p>
<p>The
<a href="https://github.com/alt-romes/haskell-x-swift-project-steps">haskell-x-swift-project-steps</a>
git repository has a commit matching each of the steps of this guide, so if
anything is unclear you can just let the code speak by itself in checking the
commits.</p>
<p>This project, blog post, and research regarding Swift interoperability with
Haskell is being partially sponsored by <a href="https://well-typed.com/">Well-Typed</a>,
and is otherwise carried out in my own free time. If you’d also like to sponsor my
work on Swift x Haskell interoperability with the goal of developing native
macOS/iOS/etc applications, visit <a href="https://github.com/sponsors/alt-romes">my GitHub sponsors
page</a>.</p>
<h2 data-number="2.1" id="further-reading"><span class="header-section-number">2.1</span> Further Reading</h2>
<ul>
<li><a href="https://github.com/nanotech/swift-haskell-tutorial/tree/master">swift-haskell-tutorial by nanotech</a></li>
<li><a href="https://www.hobson.space/posts/haskell-foreign-library/">Haskell foreign library and options: standalone</a></li>
<li><a href="https://downloads.haskell.org/ghc/latest/docs/users_guide/exts/ffi.html#using-the-ffi-with-ghc">Using the FFI with GHC</a></li>
<li><a href="https://nshipster.com/xcconfig/">xcconfig by NSHipster</a></li>
<li><a href="https://clang.llvm.org/docs/Modules.html">Clang module</a></li>
<li><a href="https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/DynamicLibraries/100-Articles/RunpathDependentLibraries.html">Run-path dependent libraries</a></li>
<li><a href="https://cabal.readthedocs.io/en/stable/">Cabal user guide</a></li>
</ul>

</article>

    </main>
    <footer>
        <small>
            Rodrigo Mesquita &copy; 2022-2023
        </small>
    </footer>
  </body>
</html>
