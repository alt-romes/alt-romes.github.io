<!doctype html>
<html lang="en">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Calling Haskell from Swift</title>
    
    <meta name="description" content="Crossing the language boundary between Haskell and Swift. This is the second part of an in-depth guide into developing native applications using Haskell with Swift.">
    
    <link rel="stylesheet" href="../css/default.css" />
    <link rel="stylesheet" href="../css/clay.css" />
    <link rel="stylesheet" href="../css/syntax.css" />

    <!-- open graph -->
    <meta property="og:title" content="Calling Haskell from Swift" />
    
    <meta property="og:description" content="Crossing the language boundary between Haskell and Swift. This is the second part of an in-depth guide into developing native applications using Haskell with Swift." />
    

    
    
    

    <!-- favicon -->
    <link rel="apple-touch-icon" sizes="180x180" href="../apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
    <link rel="manifest" href="../site.webmanifest">

    <script defer data-domain="alt-romes.github.io" src="https://plausible.io/js/script.js"></script>
  </head>
  <body>
    <nav>
      <ul>
        <li class="logo"><a href="../">romes</a></li>
        <li><a href="../posts.html">blog</a></li>
        <li>music</li>
        <!-- <li><a href="/papers.html">publications</a></li> -->
        <li>publications</li>
        <li class="hidden-small"><a href="https://github.com/alt-romes" target="_blank">github</a></li>
        <li class="hidden-small"><a href="https://gitlab.haskell.org/alt-romes" target="_blank">ghc</a></li>
      </ul>
    </nav>
    <main>
      <header>
  <div class="title">
    <h1>Calling Haskell from Swift</h1>
    <p>
      
      Jan  5, 2024
      
    </p>
  </div>
  
  <p class="description">Crossing the language boundary between Haskell and Swift. This is the second part of an in-depth guide into developing native applications using Haskell with Swift.</p>
  
  
  <ul class="tags">
    <li class="tag-haskell">#<a href="../tags/haskell.html">haskell</a></li><li class="tag-swift">#<a href="../tags/swift.html">swift</a></li>
  </ul>
  
</header>


<article>
  <div class="toc"><div class="header">Contents</div>
<ul>
<li><a href="#introduction" id="toc-introduction"><span class="toc-section-number">1</span> Introduction</a></li>
<li><a href="#marshaling-inputs-and-outputs" id="toc-marshaling-inputs-and-outputs"><span class="toc-section-number">2</span> Marshaling Inputs and Outputs</a>
<ul>
<li><a href="#haskells-perspective" id="toc-haskells-perspective"><span class="toc-section-number">2.1</span> Haskell’s Perspective</a></li>
<li><a href="#swifts-perspective" id="toc-swifts-perspective"><span class="toc-section-number">2.2</span> Swift’s Perspective</a></li>
</ul></li>
<li><a href="#metaprogramming-at-the-boundaries" id="toc-metaprogramming-at-the-boundaries"><span class="toc-section-number">3</span> Metaprogramming at the boundaries</a>
<ul>
<li><a href="#haskells-perspective-1" id="toc-haskells-perspective-1"><span class="toc-section-number">3.1</span> Haskell’s perspective</a></li>
<li><a href="#swifts-perspective-1" id="toc-swifts-perspective-1"><span class="toc-section-number">3.2</span> Swift’s perspective</a></li>
</ul></li>
<li><a href="#coercing-haskell-memory-objects-to-swift" id="toc-coercing-haskell-memory-objects-to-swift"><span class="toc-section-number">4</span> Coercing Haskell memory objects to Swift</a>
<ul>
<li><a href="#memory-representation-of-datatype-in-haskell" id="toc-memory-representation-of-datatype-in-haskell"><span class="toc-section-number">4.1</span> Memory representation of datatype in Haskell</a></li>
<li><a href="#memory-representation-of-struct-in-swift" id="toc-memory-representation-of-struct-in-swift"><span class="toc-section-number">4.2</span> Memory representation of struct in Swift</a></li>
<li><a href="#interpreting-haskell-memory-in-swift" id="toc-interpreting-haskell-memory-in-swift"><span class="toc-section-number">4.3</span> Interpreting Haskell memory in Swift</a></li>
<li><a href="#conclusion" id="toc-conclusion"><span class="toc-section-number">4.4</span> Conclusion</a></li>
</ul></li>
</ul>
</div>
<p>This is the second installment of the in-depth series of blog-posts on
developing native macOS and iOS applications using both Haskell and
Swift/SwiftUI. This post covers how to call (non-trivial) Haskell functions from
Swift by using a foreign function calling-convention strategy similar to that
described by <a href="https://well-typed.com/blog/2023/03/purgatory/">Calling Purgatory from Heaven: Binding to Rust in
Haskell</a> that requires argument
and result marshaling. Despite marshaling being required for robustly traversing
the foreign language boundary, I additionally explore calling Haskell from Swift
without any kind of marshaling by instead coercing the memory representation of
a Haskell value into a Swift one – this is mostly a (very unsafe) curiosity,
but gives me an excuse to write a bit about low-level details in Haskell!</p>
<p>You may find the other blog posts in this series interesting:</p>
<ol type="1">
<li><a href="2023-11-10-creating-a-macos-app-with-haskell-and-swift.html">Creating a macOS app with Haskell and Swift</a></li>
</ol>
<p>The series of blog posts is further accompanied by a <a href="https://github.com/alt-romes/haskell-x-swift-project-steps">github
repository</a> where
each commit matches a step of this tutorial. If in doubt regarding any step,
check the matching commit to make it clearer.
Additionally, I’m writing a build tool and libraries to facilitate the
interoperability between Haskell and Swift at <a href="https://github.com/alt-romes/haskell-swift">haskell-swift</a>.</p>
<p>This write-up has been cross-posted to <a href="https://well-typed.com/blog/">Well-Typed’s Blog</a>.</p>
<h1 data-number="1" id="introduction"><span class="header-section-number">1</span> Introduction</h1>
<p>We’ll pick up from where the last post ended – we have set up an XCode project
that includes our headers generated from Haskell modules with <code>foreign export</code>s
and links against the foreign library declared in the cabal file. We have
already been able to call a very simple Haskell function on integers from Swift
via Haskell’s C foreign export feature and Swift’s C interoperability.</p>
<p>This part concerns itself with calling idiomatic Haskell functions, which
typically involve user-defined datatypes as inputs and outputs, from Swift.
Moreover, these functions should be made available to Swift transparently, such
that Swift calls them as it does other idiomatic functions, with user defined
structs and classes.</p>
<p>For the running example, the following not-very-interesting function will
suffice to showcase the method we will use to expose this function from Haskell
to Swift, which easily scales to other complex data types and functions.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">User</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">User</span> {<span class="ot"> name ::</span> <span class="dt">String</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>         ,<span class="ot"> age  ::</span> <span class="dt">Int</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>         }</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="ot">birthday ::</span> <span class="dt">User</span> <span class="ot">-&gt;</span> <span class="dt">User</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>birthday user <span class="ot">=</span> user{age <span class="ot">=</span> user<span class="op">.</span>age <span class="op">+</span> <span class="dv">1</span>}</span></code></pre></div>
<p>should be called from Swift as</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode swift"><code class="sourceCode swift"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> User <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="va">name</span><span class="op">:</span> String</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="va">age</span><span class="op">:</span> Int</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="co">// birthday(user: User(name: &quot;Anton&quot;, age: 33)) = User(name: &quot;Anton&quot;, age: 34)</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="fu">birthday</span><span class="op">(</span><span class="va">user</span><span class="op">:</span> <span class="dt">User</span><span class="op">)</span> -&gt; <span class="fu">User</span> <span class="op">{</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Calls Haskell function...</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>To support this workflow, we need a way to <strong>convert the User datatype from
Haskell to Swift</strong>, and vice versa. There’s more than one way to do it, but we
are going to <strong>serialize (most) inputs and outputs</strong> of a function – though, in
the end, I promise to also dive a bit into coercing in-memory representations of
a datatype in between Haskell and Swift.</p>
<p>Note that, even though the serialization method here described seems complex, it
can be automated with Template Haskell and Swift Macros and packed into a neat
interface – which I’ve done at <a href="https://github.com/alt-romes/haskell-swift">haskell-swift</a>.</p>
<p>As a preliminary step, we write the <code>User</code> data type and <code>birthday</code> function to
<code>haskell-framework/src/MyLib.hs</code>, and the Swift equivalents to
<code>SwiftHaskell/ContentView.swift</code> from <a href="https://github.com/alt-romes/haskell-x-swift-project-steps"><code>haskell-x-swift-project-steps</code></a>.</p>
<h1 data-number="2" id="marshaling-inputs-and-outputs"><span class="header-section-number">2</span> Marshaling Inputs and Outputs</h1>
<p>Marshaling the inputs and outputs of a function, from the Swift perspective,
means to serialize the input values into strings, and receive the output value as
a string which is then decoded into a Swift value. The Haskell perspective is
dual.</p>
<p>Marshaling/serializing is a very robust solution to foreign language interoperability.
Despite the small overhead of encoding and decoding at a function call, it
almost automatically extends to, and enables, all sorts of data to be
transported across the language boundary, without it being vulnerable to
compiler implementation details and memory representation incompatibilities.</p>
<p>We will use the same marshaling strategy that <a href="https://well-typed.com/blog/2023/03/purgatory">Calling Purgatory from Heaven: Binding to Rust in Haskell</a> does.
In short, the idiomatic Haskell function is wrapped by a low-level one which
deserializes the Haskell values from the argument buffers, and serializes the
function result to a buffer that the caller provides. More specifically,</p>
<ul>
<li><p>For each argument of the original function, we have a <code>Ptr CChar</code> and <code>Int</code> – a string of characters and the size of that string (a.k.a <code>CStringLen</code>)</p></li>
<li><p>For the result of the original function, we have two additional arguments, <code>Ptr CChar</code> and <code>Ptr Int</code> –
an empty buffer in memory, and a pointer to the size of that buffer, both allocated by the caller.</p></li>
<li><p>For each argument, we parse the C string into a Haskell value that serves as an argument to the original function.</p></li>
<li><p>We call the original function</p></li>
<li><p>We overwrite the memory location containing the original size of the buffer with the <em>required</em> size of the buffer to fit the result (which may be smaller or larger than the actual size).
If the buffer is large enough we write the result to it.</p></li>
<li><p>From the Swift side, we read the amount of bytes specified in the memory
location that now contains the <em>required</em> size. If it turns out that the
<em>required size</em> is larger than the buffer’s size, we need to retry the
function call with a larger buffer.</p>
<ul>
<li>This means we might end up doing the work twice, if the original buffer size
is not big enough. Some engineering work might allow us to re-use the
result, but we’ll stick with retrying from scratch for simplicity.</li>
</ul></li>
</ul>
<p>We will use <code>JSON</code> as the serialization format: both Haskell and Swift have good
support for automatically deriving JSON instances and it is easier to guarantee
JSON instances match than binary order-and-alignment-dependent serialization
instances.</p>
<h2 data-number="2.1" id="haskells-perspective"><span class="header-section-number">2.1</span> Haskell’s Perspective</h2>
<p>Extending the <code>User</code> example requires <code>User</code> to be decodable, which can be done automatically by adding to the <code>User</code> declaration:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">deriving</span> stock <span class="dt">Generic</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">deriving</span> anyclass (<span class="dt">ToJSON</span>, <span class="dt">FromJSON</span>)</span></code></pre></div>
<p>With the appropriate extensions and importing the necessary modules in <code>MyLib</code>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DerivingStrategies, DeriveAnyClass #-}</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- ...</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.Generics</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Aeson</span></span></code></pre></div>
<p>The <code>MyForeignLib</code> module additionally must import</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Foreign.Ptr</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Foreign.Storable</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Foreign.Marshal</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Aeson</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.ByteString</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.ByteString.Unsafe</span></span></code></pre></div>
<p>Now, let’s (foreign) export a function <code>c_birthday</code> that wraps
<code>birthday</code> above in <code>haskell-framework/flib/MyForeignLib.hs</code>, using the
described method:</p>
<p>First, the type definition of the function receives the buffer with the <code>User</code> argument, and a
buffer to write the <code>User</code> result to. We cannot use tuples because they are not
supported in foreign export declarations, but the intuition is that the first
two arguments represent the original <code>User</code> input, and the two latter arguments
represent the returned <code>User</code>.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">c_birthday ::</span> <span class="dt">Ptr</span> <span class="dt">CChar</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Ptr</span> <span class="dt">CChar</span> <span class="ot">-&gt;</span> <span class="dt">Ptr</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span></code></pre></div>
<p>Then, the implementation – decode the argument, encode the result, write
result size to the given memory location and the result itself to the buffer, if
it fits.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>c_birthday cstr clen result size_ptr <span class="ot">=</span> <span class="kw">do</span></span></code></pre></div>
<p>We transform the <code>(Ptr CChar, Int)</code> pair into a <code>ByteString</code> using
<code>unsafePackCStringLen</code>, and decode a <code>User</code> from the <code>ByteString</code> using
<code>decodeStrict</code>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- (1) Decode C string</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Just</span> user <span class="ot">&lt;-</span> decodeStrict <span class="op">&lt;$&gt;</span> unsafePackCStringLen (cstr, clen)</span></code></pre></div>
<p>We apply the original <code>birthday</code> function to the decoded <code>user</code>. In our example,
this is a very boring function, but in reality this is likely a complex
idiomatic Haskell function that we want to expose to.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- (2) Apply `birthday`</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> user_new <span class="ot">=</span> birthday user</span></code></pre></div>
<p>We encode the <code>new_user :: User</code> as a <code>ByteString</code>, and use
<code>unsafeUseAsCStringLen</code> to get a pointer to the bytestring data and its length.
Finally, we get the size of the result buffer, write the actual size of the
result to the given memory location, and, if the actual size fits the buffer,
copy the bytes from the bytestring to the given buffer.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- (3) Encode result</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  unsafeUseAsCStringLen (toStrict <span class="op">$</span> encode user_new) <span class="op">$</span> \(ptr,len) <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- (3.2) What is the size of the result buffer?</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    size_avail <span class="ot">&lt;-</span> peek size_ptr</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- (3.3) Write actual size to the int ptr.</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    poke size_ptr len</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- (3.4) If sufficient, we copy the result bytes to the given result buffer</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> size_avail <span class="op">&lt;</span> len</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>       <span class="kw">then</span> <span class="kw">do</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>         <span class="co">-- We need @len@ bytes available</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>         <span class="co">-- The caller has to retry</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>         <span class="fu">return</span> ()</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>       <span class="kw">else</span> <span class="kw">do</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>         moveBytes result ptr len</span></code></pre></div>
<p>If the written <em>required</em> size is larger than the given buffer, the caller will
retry.</p>
<p>Of course, we must export this as a C function.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>foreign export ccall<span class="ot"> c_birthday ::</span> <span class="dt">Ptr</span> <span class="dt">CChar</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Ptr</span> <span class="dt">CChar</span> <span class="ot">-&gt;</span> <span class="dt">Ptr</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span></code></pre></div>
<p>This makes the <code>c_birthday</code> function wrapper available to Swift in the generated
header and at link time in the dynamic library.</p>
<h2 data-number="2.2" id="swifts-perspective"><span class="header-section-number">2.2</span> Swift’s Perspective</h2>
<p>In Swift, we want to be able to call the functions exposed from Haskell via
their wrappers, from a wrapper that feels native to Swift itself. In our
example, that means wrapping a call to <code>c_birthday</code> in a new Swift <code>birthday</code>
function.</p>
<p>In <code>ContentView.swift</code>, we make <code>User</code> JSON-encodable/decodable by conforming to
the <code>Codable</code> protocol:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode swift"><code class="sourceCode swift"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> User<span class="op">:</span> <span class="dt">Codable</span> <span class="op">{</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Then, we implement the Swift side of <code>birthday</code> which <em>simply</em> calls
<code>c_birthday</code> – the whole logic of <code>birthday</code> is handled by the Haskell side
function (recall that <code>birthday</code> could be incredibly complex, and other
functions exposed by Haskell will indeed be).</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode swift"><code class="sourceCode swift"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="fu">birthday</span><span class="op">(</span><span class="va">user</span><span class="op">:</span> <span class="dt">User</span><span class="op">)</span> -&gt; <span class="fu">User</span> <span class="op">{</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Note: in the implementation, a couple of blocks have to be wrapped with a <code>do { ... } catch X { ... }</code> but I omit them in this text. You can see the commit
relevant to the Swift function wrapper implementation in the repo with all of
these details included.</p>
<p>First, we encode the Swift argument into a binary representation (<code>Data</code>) (plus its length) that will serve
as arguments to the foreign C function.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode swift"><code class="sourceCode swift"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="va">enc</span> <span class="op">=</span> JSONEncoder<span class="op">()</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="va">dec</span> <span class="op">=</span> JSONDecoder<span class="op">()</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> <span class="va">data</span><span class="op">:</span> Data <span class="op">=</span> <span class="cf">try</span> enc<span class="op">.</span>encode<span class="op">(</span>user<span class="op">)</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="va">data_len</span> <span class="op">=</span> Int64<span class="op">(</span>data<span class="op">.</span>count<span class="op">)</span></span></code></pre></div>
<p>However, a Swift <code>Data</code> value, which represents binary data, cannot be passed
directly to C as a pointer. For that, we must use <code>withUnsafeMutableBytes</code> to
get an <code>UnsafeMutableRawBufferPointer</code> out of the <code>Data</code> – that we can pass to
the C foreign function. <code>withUnsafeMutableBytes</code> receives a closure that uses an
<code>UnsafeMutableRawBufferPointer</code> in its scope and returns the value returned by
the closure. Therefore we can return the result of calling it on the user <code>Data</code>
we encoded right away:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode swift"><code class="sourceCode swift"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">return</span> data<span class="op">.</span>withUnsafeMutableBytes <span class="op">{</span> <span class="op">(</span>rawPtr<span class="op">:</span> UnsafeMutableRawBufferPointer<span class="op">)</span> <span class="cf">in</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// here goes the closure that can use the raw pointer,</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// the code for which we describe below</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>We allocate a buffer for the C foreign function to insert the result of
calling the Haskell function, and also allocate memory to store the size of the
buffer. We use <code>withUnsafeTemporaryAllocation</code> to allocate a buffer that can be
used in the C foreign function call. As for <code>withUnsafeMutableBytes</code>, this
function also takes a closure and returns the value returned by the closure:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode swift"><code class="sourceCode swift"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co">// The data buffer size</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="va">buf_size</span> <span class="op">=</span> <span class="dv">1024000</span> <span class="co">// 1024KB</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="co">// A size=1 buffer to store the length of the result buffer</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="kw">return</span> withUnsafeTemporaryAllocation<span class="op">(</span>of<span class="op">:</span> Int<span class="op">.</span><span class="kw">self</span><span class="op">:</span> <span class="dv">1</span><span class="op">)</span> <span class="op">{</span> size_ptr <span class="cf">in</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Store the buffer size in this memory location</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>    size_ptr<span class="op">.</span>baseAddress<span class="op">?.</span>pointee <span class="op">=</span> buf_size</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Allocate the buffer for the result (we need to wrap this in a do { ...} catch for reasons explained below)</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">do</span> <span class="op">{</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">return</span> withUnsafeTemporaryAllocation<span class="op">(</span>byteCount<span class="op">:</span> buf_size<span class="op">,</span> alignment<span class="op">:</span><span class="dv">1</span><span class="op">)</span> <span class="op">{</span> res_ptr <span class="cf">in</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Continues from here ...</span></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">catch</span> <span class="co">// We continue here in due time ...</span></span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>We are now nested deep within 3 closures: one binds the pointer to the
argument’s data, the other the pointer to the buffer size, and the other the
result buffer pointer. This means we can now call the C foreign function
wrapping the Haskell function:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode swift"><code class="sourceCode swift"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>c_birthday<span class="op">(</span>rawPtr<span class="op">.</span>baseAddress<span class="op">,</span> data_len<span class="op">,</span> res_ptr<span class="op">.</span>baseAddress<span class="op">,</span> size_ptr<span class="op">.</span>baseAddress<span class="op">)</span></span></code></pre></div>
<p>Recalling that the Haskell side will update the size pointed to by <code>size_ptr</code> to
the size required to serialize the encoded result, we need to check if
this required size exceeds the buffer we allocated, or read the data otherwise:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode swift"><code class="sourceCode swift"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="kw">let</span> <span class="va">required_size</span> <span class="op">=</span> size_ptr<span class="op">.</span>baseAddress<span class="op">?.</span>pointee <span class="op">{</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> required_size <span class="op">&gt;</span> buf_size <span class="op">{</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Need to try again</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">throw</span> HsFFIError<span class="op">.</span>requiredSizeIs<span class="op">(</span>required_size<span class="op">)</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a><span class="kw">return</span> dec<span class="op">.</span>decode<span class="op">(</span>User<span class="op">.</span><span class="kw">self</span><span class="op">,</span> from<span class="op">:</span> Data<span class="op">(</span>bytesNoCopy<span class="op">:</span> res_ptr<span class="op">.</span>baseAddress<span class="op">!,</span> count<span class="op">:</span> size_ptr<span class="op">.</span>baseAddress<span class="op">?.</span>pointee <span class="op">??</span> <span class="dv">0</span><span class="op">,</span> deallocator<span class="op">:</span> <span class="op">.</span>none<span class="op">))</span></span></code></pre></div>
<p>where <code>HsFFIError</code> is a custom error defined as</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode swift"><code class="sourceCode swift"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> HsFFIError<span class="op">:</span> <span class="dt">Error</span> <span class="op">{</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> requiredSizeIs<span class="op">(</span>Int<span class="op">)</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>We must now fill in the <code>catch</code> block to retry the foreign function call with a
buffer of the right size:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode swift"><code class="sourceCode swift"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="cf">catch</span> HsFFIError<span class="op">.</span>requiredSizeIs<span class="op">(</span><span class="kw">let</span> <span class="va">required_size</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> withUnsafeTemporaryAllocation<span class="op">(</span>byteCount<span class="op">:</span> required_size<span class="op">,</span> alignment<span class="op">:</span><span class="dv">1</span><span class="op">)</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span> res_ptr <span class="cf">in</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>        size_ptr<span class="op">.</span>baseAddress<span class="op">?.</span>pointee <span class="op">=</span> required_size</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>        c_birthday<span class="op">(</span>rawPtr<span class="op">.</span>baseAddress<span class="op">,</span> data_len<span class="op">,</span> res_ptr<span class="op">.</span>baseAddress<span class="op">,</span> size_ptr<span class="op">.</span>baseAddress<span class="op">)</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">return</span> dec<span class="op">.</span>decode<span class="op">(</span>User<span class="op">.</span><span class="kw">self</span><span class="op">,</span> from<span class="op">:</span> Data<span class="op">(</span>bytesNoCopy<span class="op">:</span> res_ptr<span class="op">.</span>baseAddress<span class="op">!,</span> count<span class="op">:</span> size_ptr<span class="op">.</span>baseAddress<span class="op">?.</span>pointee <span class="op">??</span> <span class="dv">0</span><span class="op">,</span> deallocator<span class="op">:</span> <span class="op">.</span>none<span class="op">))</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>That seems like a lot of work to call a function from Haskell! However, despite
this being a lot of code, not a whole lot is happening: we simply serialize the
argument, allocate a buffer for the result, and deserialize the result into it.
In the worst case, if the serialized result does not fit (the serialized data
has over 100 thousand characters), then we <em>naively</em> compute the function a
second time (it would not be terribly complicated to avoid this work by caching
the result and somehow resuming the serialization with the new buffer).
Furthermore, there is a lot of bureocracy in getting the raw pointers to send
off to Haskell land – the good news is that all of this can be automated away
behind automatic code generation with Template Haskell and Swift Macros.</p>
<details>
<summary>
Expand for the complete function
</summary>
<div class="sourceCode" id="cb21"><pre class="sourceCode swift"><code class="sourceCode swift"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="fu">birthday</span> <span class="op">(</span><span class="va">user</span> <span class="op">:</span> <span class="dt">User</span><span class="op">)</span> -&gt; <span class="fu">User</span> <span class="op">{</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="va">enc</span> <span class="op">=</span> JSONEncoder<span class="op">()</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="va">dec</span> <span class="op">=</span> JSONDecoder<span class="op">()</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">do</span> <span class="op">{</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">var</span> <span class="va">data</span> <span class="op">:</span> Data <span class="op">=</span> <span class="cf">try</span> enc<span class="op">.</span>encode<span class="op">(</span>user<span class="op">)</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> <span class="va">data_len</span> <span class="op">=</span> Int64<span class="op">(</span>data<span class="op">.</span>count<span class="op">)</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">return</span> <span class="cf">try</span> data<span class="op">.</span>withUnsafeMutableBytes <span class="op">{</span> <span class="op">(</span>rawPtr<span class="op">:</span>UnsafeMutableRawBufferPointer<span class="op">)</span> <span class="cf">in</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Allocate buffer for result</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> <span class="va">buf_size</span> <span class="op">=</span> <span class="dv">1024000</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>            <span class="kw">return</span> <span class="cf">try</span> withUnsafeTemporaryAllocation<span class="op">(</span>of<span class="op">:</span> Int<span class="op">.</span><span class="kw">self</span><span class="op">,</span> capacity<span class="op">:</span> <span class="dv">1</span><span class="op">)</span> <span class="op">{</span> size_ptr <span class="cf">in</span></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>                size_ptr<span class="op">.</span>baseAddress<span class="op">?.</span>pointee <span class="op">=</span> buf_size</span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a>                <span class="cf">do</span> <span class="op">{</span></span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">return</span> <span class="cf">try</span> withUnsafeTemporaryAllocation<span class="op">(</span>byteCount<span class="op">:</span> buf_size<span class="op">,</span> alignment<span class="op">:</span> <span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a> res_ptr <span class="cf">in</span></span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a>                        c_birthday<span class="op">(</span>rawPtr<span class="op">.</span>baseAddress<span class="op">,</span> data_len<span class="op">,</span> res_ptr<span class="op">.</span>baseAddress<span class="op">,</span> size_ptr<span class="op">.</span>baseAddress<span class="op">)</span></span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">if</span> <span class="kw">let</span> <span class="va">required_size</span> <span class="op">=</span> size_ptr<span class="op">.</span>baseAddress<span class="op">?.</span>pointee <span class="op">{</span></span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true" tabindex="-1"></a>                            <span class="cf">if</span> required_size <span class="op">&gt;</span> buf_size <span class="op">{</span></span>
<span id="cb21-23"><a href="#cb21-23" aria-hidden="true" tabindex="-1"></a>                                <span class="kw">throw</span> HsFFIError<span class="op">.</span>requiredSizeIs<span class="op">(</span>required_size<span class="op">)</span></span>
<span id="cb21-24"><a href="#cb21-24" aria-hidden="true" tabindex="-1"></a>                            <span class="op">}</span></span>
<span id="cb21-25"><a href="#cb21-25" aria-hidden="true" tabindex="-1"></a>                        <span class="op">}</span></span>
<span id="cb21-26"><a href="#cb21-26" aria-hidden="true" tabindex="-1"></a>                        <span class="kw">return</span> <span class="cf">try</span> dec<span class="op">.</span>decode<span class="op">(</span>User<span class="op">.</span><span class="kw">self</span><span class="op">,</span> from<span class="op">:</span> Data<span class="op">(</span>bytesNoCopy<span class="op">:</span> res_ptr<span class="op">.</span>baseAddress<span class="op">!,</span> count<span class="op">:</span> size_ptr<span class="op">.</span>baseAddress<span class="op">?.</span>pointee <span class="op">??</span> <span class="dv">0</span><span class="op">,</span> deallocator<span class="op">:</span> <span class="op">.</span>none<span class="op">))</span></span>
<span id="cb21-27"><a href="#cb21-27" aria-hidden="true" tabindex="-1"></a>                    <span class="op">}</span></span>
<span id="cb21-28"><a href="#cb21-28" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span> <span class="cf">catch</span> HsFFIError<span class="op">.</span>requiredSizeIs<span class="op">(</span><span class="kw">let</span> <span class="va">required_size</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb21-29"><a href="#cb21-29" aria-hidden="true" tabindex="-1"></a>                    print<span class="op">(</span><span class="st">&quot;Retrying with required size: </span><span class="er">\(</span><span class="st">required_size)&quot;</span><span class="op">)</span></span>
<span id="cb21-30"><a href="#cb21-30" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">return</span> <span class="cf">try</span> withUnsafeTemporaryAllocation<span class="op">(</span>byteCount<span class="op">:</span> required_size<span class="op">,</span> alignment<span class="op">:</span></span>
<span id="cb21-31"><a href="#cb21-31" aria-hidden="true" tabindex="-1"></a> <span class="dv">1</span><span class="op">)</span> <span class="op">{</span> res_ptr <span class="cf">in</span></span>
<span id="cb21-32"><a href="#cb21-32" aria-hidden="true" tabindex="-1"></a>                        size_ptr<span class="op">.</span>baseAddress<span class="op">?.</span>pointee <span class="op">=</span> required_size</span>
<span id="cb21-33"><a href="#cb21-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-34"><a href="#cb21-34" aria-hidden="true" tabindex="-1"></a>                        c_birthday<span class="op">(</span>rawPtr<span class="op">.</span>baseAddress<span class="op">,</span> data_len<span class="op">,</span> res_ptr<span class="op">.</span>baseAddress<span class="op">,</span> size_ptr<span class="op">.</span>baseAddress<span class="op">)</span></span>
<span id="cb21-35"><a href="#cb21-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-36"><a href="#cb21-36" aria-hidden="true" tabindex="-1"></a>                        <span class="kw">return</span> <span class="cf">try</span> dec<span class="op">.</span>decode<span class="op">(</span>User<span class="op">.</span><span class="kw">self</span><span class="op">,</span> from<span class="op">:</span> Data<span class="op">(</span>bytesNoCopy<span class="op">:</span> res_ptr<span class="op">.</span>baseAddress<span class="op">!,</span> count<span class="op">:</span> size_ptr<span class="op">.</span>baseAddress<span class="op">?.</span>pointee <span class="op">??</span> <span class="dv">0</span><span class="op">,</span> deallocator<span class="op">:</span> <span class="op">.</span>none<span class="op">))</span></span>
<span id="cb21-37"><a href="#cb21-37" aria-hidden="true" tabindex="-1"></a>                    <span class="op">}</span></span>
<span id="cb21-38"><a href="#cb21-38" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb21-39"><a href="#cb21-39" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb21-40"><a href="#cb21-40" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb21-41"><a href="#cb21-41" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">catch</span> <span class="op">{</span></span>
<span id="cb21-42"><a href="#cb21-42" aria-hidden="true" tabindex="-1"></a>        print<span class="op">(</span><span class="st">&quot;Error decoding JSON probably: </span><span class="er">\(</span><span class="st">error)&quot;</span><span class="op">)</span></span>
<span id="cb21-43"><a href="#cb21-43" aria-hidden="true" tabindex="-1"></a>        <span class="kw">return</span> User<span class="op">(</span>name<span class="op">:</span> <span class="st">&quot;&quot;</span><span class="op">,</span> age<span class="op">:</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb21-44"><a href="#cb21-44" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb21-45"><a href="#cb21-45" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</details>
<p>We can test that this is working by replacing <code>ContentView</code> with:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode swift"><code class="sourceCode swift"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> ContentView<span class="op">:</span> <span class="dt">View</span> <span class="op">{</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">var</span> <span class="va">body</span><span class="op">:</span> some View <span class="op">{</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>        VStack <span class="op">{</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> <span class="va">user</span> <span class="op">=</span> birthday<span class="op">(</span>user<span class="op">:</span> User<span class="op">(</span>name<span class="op">:</span> <span class="st">&quot;Ellie&quot;</span><span class="op">,</span> age<span class="op">:</span> <span class="dv">24</span><span class="op">))</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>            Text<span class="op">(</span><span class="st">&quot;Post-birthday, </span><span class="er">\(</span><span class="st">user.name) is: </span><span class="er">\(</span><span class="st">user.age)!&quot;</span><span class="op">)</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>padding<span class="op">()</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>And you should see:</p>
<figure>
<img src="../images/calling-haskell-from-swift/ss1.jpeg" alt="Fig 1. Swift app displays result of calling idiomatic Haskell function via idiomatic Swift wrapper" />
<figcaption aria-hidden="true">Fig 1. Swift app displays result of calling idiomatic Haskell function via idiomatic Swift wrapper</figcaption>
</figure>
<h1 data-number="3" id="metaprogramming-at-the-boundaries"><span class="header-section-number">3</span> Metaprogramming at the boundaries</h1>
<p>I want to give a quick preview of what is made possible by using compile-time
code generation features (Template Haskell in Haskell, Swift Macros in Swift).
This foreign function code generation API is exposed by the
<a href="https://github.com/alt-romes/haskell-swift">haskell-swift</a> project, namely the
<code>swift-ffi</code> Haskell library and <code>haskell-ffi</code> Swift package. (Since it is out of
the scope of this tutorial, I will not cover how exactly the compile-time
code-generation code works, but instead use the API provided by these libraries)</p>
<p>These top-level foreign interaction facilities, coupled with the build tool also
provided by <a href="https://github.com/alt-romes/haskell-swift">haskell-swift</a>, one can
easily bootstrap and develop programs mixing Haskell and Swift! (Look forward to
a tutorial on bootstrapping and developing such a mixed project in the near future).</p>
<p>Let us consider the same example where we define an idiomatic <code>birthday :: User -&gt; User</code> function in Haskell and want to be able to call it from Swift as
<code>birthday(user: User) -&gt; User</code></p>
<h2 data-number="3.1" id="haskells-perspective-1"><span class="header-section-number">3.1</span> Haskell’s perspective</h2>
<p>To expose the <code>birthday</code> function to Swift, we simply use the <code>foreignExportSwift</code>
Template Haskell function. The whole module could look like this:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TemplateHaskell #-}</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">MyLib</span> <span class="kw">where</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- ...</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Swift.FFI</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">User</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a> <span class="ot">=</span> <span class="dt">User</span> {<span class="ot"> name ::</span> <span class="dt">String</span></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>        ,<span class="ot"> age  ::</span> <span class="dt">Int</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">deriving</span> stock    <span class="dt">Generic</span></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">deriving</span> anyclass <span class="dt">FromJSON</span></span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a>        <span class="kw">deriving</span> anyclass <span class="dt">ToJSON</span></span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a><span class="ot">birthday ::</span> <span class="dt">User</span> <span class="ot">-&gt;</span> <span class="dt">User</span></span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true" tabindex="-1"></a>birthday <span class="dt">User</span>{age<span class="ot">=</span>x, name<span class="ot">=</span>y} <span class="ot">=</span> <span class="dt">User</span>{age<span class="ot">=</span>x<span class="op">+</span><span class="dv">1</span>, name<span class="ot">=</span>y}</span>
<span id="cb23-17"><a href="#cb23-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-18"><a href="#cb23-18" aria-hidden="true" tabindex="-1"></a><span class="op">$</span>(foreignExportSwift 'birthday)</span></code></pre></div>
<p>The key bit is the last <code>foreignExportSwift</code> call which will expose a C function
with the marshalling-based calling convention we outlined above.</p>
<h2 data-number="3.2" id="swifts-perspective-1"><span class="header-section-number">3.2</span> Swift’s perspective</h2>
<p>On the Swift side, we want to use the dual <code>@ForeignImportSwift</code> macro which
generates a Swift function wrapper which in turn invokes the C function exposed
by Haskell with the above marshalling strategy. The Swift file could
look like:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode swift"><code class="sourceCode swift"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="im">HaskellFFI</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> User<span class="op">:</span> <span class="dt">Codable</span> <span class="op">{</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="va">name</span><span class="op">:</span> String</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="va">age</span><span class="op">:</span> Int</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a><span class="at">@ForeignImportHaskell</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="fu">birthday</span><span class="op">(</span><span class="va">cconv</span><span class="op">:</span> <span class="dt">HsCallJSON</span><span class="op">,</span> <span class="va">user</span><span class="op">:</span> <span class="dt">User</span><span class="op">)</span> -&gt; <span class="fu">User</span> <span class="op">{</span> stub<span class="op">()</span> <span class="op">}</span></span></code></pre></div>
<p>where <code>birthday</code> could be called e.g. as:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode swift"><code class="sourceCode swift"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>birthday<span class="op">(</span>user<span class="op">:</span> User<span class="op">(</span>name<span class="op">:</span> <span class="st">&quot;Pierre&quot;</span><span class="op">,</span> age<span class="op">:</span> <span class="dv">55</span><span class="op">))</span></span></code></pre></div>
<h1 data-number="4" id="coercing-haskell-memory-objects-to-swift"><span class="header-section-number">4</span> Coercing Haskell memory objects to Swift</h1>
<p>Welcome to the dark corner (section?) of this blog post: the part where we
unsafely coerce an object in the Haskell heap into Swift. This section
will serve to walk the reader through some of the lower level details of
Haskell, and explore what it could mean to not marshal data between the language
boundary.</p>
<p>Even though we will avoid serialization and coerce memory representations, we
will still go through the C foreign function interface. In theory, it should be
possible to figure out the ABI/how to call Haskell symbols and somehow load and
call them in the Swift program accordingly, but I didn’t go that far.</p>
<p>Changing up the data types a bit, also to avoid Strings because their memory
representations both in Haskell and Swift are complex to figure out, we have</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode swift"><code class="sourceCode swift"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Rect <span class="op">{</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="va">width</span><span class="op">:</span> Int</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="va">height</span><span class="op">:</span> Int</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="fu">double</span><span class="op">(</span><span class="va">sq</span><span class="op">:</span> <span class="dt">Rect</span><span class="op">)</span> -&gt; <span class="fu">Rect</span> <span class="op">{</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// wants to call /directly/ the Haskell function</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>and</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Rect</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Rect</span> {<span class="ot"> width ::</span> <span class="dt">Int</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>         ,<span class="ot"> height ::</span> <span class="dt">Int</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>         }</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a><span class="ot">double ::</span> <span class="dt">Rect</span> <span class="ot">-&gt;</span> <span class="dt">Rect</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>double <span class="dt">Rect</span>{width<span class="ot">=</span>x, height<span class="ot">=</span>y} <span class="ot">=</span> <span class="dt">Rect</span>{width<span class="ot">=</span>x<span class="op">*</span><span class="dv">2</span>, height<span class="ot">=</span>y<span class="op">*</span><span class="dv">2</span>}</span></code></pre></div>
<h2 data-number="4.1" id="memory-representation-of-datatype-in-haskell"><span class="header-section-number">4.1</span> Memory representation of datatype in Haskell</h2>
<p>In Haskell, most values are heap-allocated. This means that in the following
program, <code>x</code> is a pointer to a heap object of type <code>Rect</code>:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>myrect <span class="ot">=</span> <span class="dt">Rect</span>{width<span class="ot">=</span><span class="dv">12</span>, height<span class="ot">=</span><span class="dv">24</span>}</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>area <span class="ot">=</span> <span class="fu">putStrLn</span> (<span class="st">&quot;Area: &quot;</span> <span class="op">++</span> <span class="fu">show</span> (width myrect <span class="op">*</span> height myrect))</span></code></pre></div>
<p>We can actually inspect the memory representation of x by looking at the <code>C--</code>
code resulting from compiling this program standalone (<code>C--</code> is an intermediate
representation used by the Glasgow Haskell Compiler, which sits somewhere
between C and Assembly, and is in fact further compiled to Assembly by the
compiler in subsequent steps). Conjure up the invocation:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="ex">ghc</span> <span class="at">-fforce-recomp</span> <span class="at">-ddump-cmm</span> Memory.hs <span class="op">&gt;</span> Memory.cmm</span></code></pre></div>
<p>Opening <code>area.cmm</code> we can find the symbol <code>myrect</code>:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>section <span class="st">&quot;&quot;</span>data<span class="st">&quot; . Memory.myrect_closure&quot;</span> <span class="op">{</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>     Memory<span class="op">.</span>myrect_closure<span class="op">:</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>         <span class="dt">const</span> Memory<span class="op">.</span>Rect_con_info<span class="op">;</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>         <span class="dt">const</span> stg_INTLIKE_closure<span class="op">+</span><span class="dv">449</span><span class="op">;</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>         <span class="dt">const</span> stg_INTLIKE_closure<span class="op">+</span><span class="dv">641</span><span class="op">;</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>         <span class="dt">const</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Essentially, the <code>myrect_closure</code> label points to 4 words: a <code>con_info</code> which
is metadata about the constructor used, 2 words have an <code>stg_INTLIKE_closure</code>,
which are the integers <code>12</code> and <code>24</code> that we used, and the last word is the
static link field (grep for <code>Note [STATIC_LINK fields]</code> in the GHC codebase for
details).</p>
Note that the integers are not their literal number because the <code>Int</code> datatype
is also heap allocated (as almost everything else in Haskell). Instead, they are
static pointers to known integer values (two occurrences of the same integer will
use share the same location and pointer).
<details>
<summary>
Here’s a short GHC note about integer closures
</summary>
<div class="sourceCode" id="cb31"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>Note [CHARLIKE and INTLIKE closures]</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>These are static representations of Chars and small Ints, so that</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>we can remove dynamic Chars and Ints during garbage collection and</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>replace them with references to the static objects.</span></code></pre></div>
</details>
<h2 data-number="4.2" id="memory-representation-of-struct-in-swift"><span class="header-section-number">4.2</span> Memory representation of struct in Swift</h2>
<p>In Swift’s side we can try a similar thing, let’s compile a standalone Swift
program with the <code>Rect</code> struct defininition and with a top-level binding:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode swift"><code class="sourceCode swift"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="fu">makeRect</span><span class="op">(</span><span class="va">w</span><span class="op">:</span> <span class="dt">Int</span><span class="op">,</span> <span class="va">h</span><span class="op">:</span> <span class="dt">Int</span><span class="op">)</span> -&gt; <span class="fu">Rect</span> <span class="op">{</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> Rect<span class="op">(</span>width<span class="op">:</span> <span class="dv">533</span><span class="op">,</span> height<span class="op">:</span><span class="dv">6464</span><span class="op">)</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>and chant the invocation with the flag to print the LLVM IR generated code:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="ex">swiftc</span> Rect.swift <span class="at">-emit-ir</span> <span class="at">-o</span> <span class="at">-</span> <span class="kw">|</span> <span class="ex">swift</span> demangle <span class="op">&gt;</span> Rect.S</span></code></pre></div>
<p>Grepping <code>Rect.S</code> for <code>Rect</code> you should find:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode llvm"><code class="sourceCode llvm"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="fu">%T4main4RectV</span> = <span class="kw">type</span> &lt;{ <span class="fu">%TSi</span>, <span class="fu">%TSi</span> }&gt;</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="fu">%TSi</span> = <span class="kw">type</span> &lt;{ <span class="dt">i64</span> }&gt;</span></code></pre></div>
This syntax identifies the LLVM type of <code>Rect</code> to be a <a href="https://llvm.org/docs/LangRef.html#t-struct">packed
structure</a> of two 64bit integers.
<details>
<summary>
Here’s an excerpt from the LLVM documentation on packed structures
</summary>
<div class="sourceCode" id="cb35"><pre class="sourceCode llvm"><code class="sourceCode llvm"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="co">; Syntax</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a><span class="fu">%T1</span> = <span class="kw">type</span> { &lt;<span class="kw">type</span> list&gt; }     <span class="co">; Identified normal struct type</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a><span class="fu">%T2</span> = <span class="kw">type</span> &lt;{ &lt;<span class="kw">type</span> list&gt; }&gt;   <span class="co">; Identified packed struct type</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a><span class="co">; Examples:</span></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>{ <span class="dt">i32</span>, <span class="dt">i32</span>, <span class="dt">i32</span> } <span class="co">; A triple of three i32 values</span></span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>{ <span class="dt">float</span>, ptr } <span class="co">; A pair, where the first element is a float and the second element is a pointer.</span></span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a>&lt;{ <span class="dt">i8</span>, <span class="dt">i32</span> }&gt; <span class="co">; A packed struct known to be 5 bytes in size.</span></span></code></pre></div>
</details>
<p>In short, the <code>Rect</code> type is a <code>type &lt;{ i64, i64 }&gt;</code> which means 8*2 bytes in memory.
To double check, we can look for the <code>makeRect</code> function that should return
exactly a 16 byte structure.</p>
<h2 data-number="4.3" id="interpreting-haskell-memory-in-swift"><span class="header-section-number">4.3</span> Interpreting Haskell memory in Swift</h2>
<p>Summarising, a <code>Rect</code> value in Swift will look like (A) in memory, and a Haskell
<code>Rect</code> value will look like (B) in memory:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>    ┌────┬────┐</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>(A) │ 533│6464│</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>    └────┴────┘</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>    ┌────┐                        </span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>(B) │    │                        </span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>    └─┬──┘                        </span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a>      │   ┌────┬────┬────┬────┐   </span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a>      └──►│Rect│    │    │  3 │   </span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a>          └────┴┬───┴─┬──┴────┘   </span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a>                │     │           </span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true" tabindex="-1"></a>          ┌─────┘     └─┐         </span>
<span id="cb36-13"><a href="#cb36-13" aria-hidden="true" tabindex="-1"></a>          │             │         </span>
<span id="cb36-14"><a href="#cb36-14" aria-hidden="true" tabindex="-1"></a>         ┌▼───┬────┐   ┌▼───┬────┐</span>
<span id="cb36-15"><a href="#cb36-15" aria-hidden="true" tabindex="-1"></a>         │ I# │ 12 │   │ I# │ 12 │</span>
<span id="cb36-16"><a href="#cb36-16" aria-hidden="true" tabindex="-1"></a>         └────┴────┘   └────┴────┘</span></code></pre></div>
<p>The first thing we can address is storing the unboxed integers in the fields of
the Haskell datatype instead of static closures to boxed integers. To do this,
we make the field strict with the <code>!</code> annotation, and we use the <code>{-# UNPACK #-}</code> pragma to force the unboxing when compiling with optimisations (although it
is likely that compiling with optimisations will unbox the strict integer
anyway without the pragma<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>). That is, update <code>Rect</code> to the following,
recompile, and check the <code>C--</code> representation again.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Rect</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Rect</span> {<span class="ot"> width ::</span> <span class="ot">{-# UNPACK #-}</span> <span class="op">!</span><span class="dt">Int</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>         ,<span class="ot"> height ::</span> <span class="ot">{-# UNPACK #-}</span> <span class="op">!</span><span class="dt">Int</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>         }</span></code></pre></div>
<p>You’ll see that compiling with optimisations will get rid of the static link
field and store literal integers in the fields of the datatype:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>Memory<span class="op">.</span>myrect_closure<span class="op">:</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">const</span> Memory<span class="op">.</span>Rect_con_info<span class="op">;</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">const</span> <span class="dv">12</span><span class="op">;</span></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">const</span> <span class="dv">24</span><span class="op">;</span></span></code></pre></div>
<p>The memory now looking like</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>       ┌────┐                        </span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>myrect │    │                        </span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>       └─┬──┘                        </span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>         │   ┌────┬────┬────┐</span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>         └──►│Rect│ 12 │ 24 │  </span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>             └────┴────┴────┘   </span></code></pre></div>
<h3 data-number="4.3.1" id="unsafe-coercing"><span class="header-section-number">4.3.1</span> Unsafe Coercing</h3>
<p>It seems much simpler how we can return from a C function wrapping a Haskell
function a value which can be understood as a <code>struct Rect</code> in Swift. We need
to:</p>
<ol type="1">
<li>Unsafe coerce <code>myrect :: Rect</code> into a <code>myrect :: Ptr ()</code>, a pointer to the beginning of
the Rect heap<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> object</li>
<li>Add the size of a word to the <code>myrect</code> pointer, to get a pointer pointing to the
beginning of the integer data (points to the field with <code>12</code>).</li>
</ol>
<p>But this will not work. The problem is that occurrences of <code>myrect</code> in a
function body will not actually be a pointer to the first word of the Haskell
value in the heap. It is rather the pointer we want plus 1 (i.e. <code>myrect = ptr_to_rect_value_in_heap+1</code>).
We can see this by looking again at <code>C--</code> for this simple function:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="ot">giveMyRect ::</span> () <span class="ot">-&gt;</span> <span class="dt">Rect</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>giveMyRect () <span class="ot">=</span> myrect</span></code></pre></div>
<p>Whose corresponding <code>C--</code> code looks like:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>Memory<span class="op">.</span>giveMyRect_entry<span class="op">()</span> <span class="op">{</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>   <span class="co">// ...</span></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>   R1 <span class="op">=</span> Memory<span class="op">.</span>myrect_closure<span class="op">+</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>   Sp <span class="op">=</span> Sp <span class="op">+</span> <span class="dv">8</span><span class="op">;</span></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>   call <span class="op">(</span>P64<span class="op">[</span>Sp<span class="op">])(</span>R1<span class="op">)</span></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Note how we return <code>myrect_closure+1</code>, the pointer to the <code>myrect_closure</code> plus
the tag.</p>
<p>The short story is that GHC will use an optimisation technique called <a href="https://en.wikipedia.org/wiki/Tagged_pointer"><em>pointer
tagging</em></a> to add a tag to every
heap pointer denoting which of the datatype constructors was used to construct
that value, or whether the value has not yet been evaluated:</p>
<ul>
<li>If the tag is <code>0</code> then the pointed-to value is either unevaluated or we don’t
know</li>
<li>If the tag is <code>1</code> then we know the pointed-to value to have been constructed
with the first constructor of the datatype</li>
<li>If the tag is <code>2</code> then we know the pointed-to value to have been constructed
with the second constructor of the datatype, and on and on up until <code>7</code>,
which is the last possible tag<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>.</li>
</ul>
<p>This is a very cool optimisation because it allows us to choose the branch of
a case expression without needing to de-reference the pointer to check which
constructor the value used, as long as it has already been evaluated, because we
can simply check the tag, or e.g. avoiding memory accesses to check if a value
has already been evaluated as we can know, again, simply by looking at the tag.</p>
<p>So, we really need another step:</p>
<p>1.5. Subtract <code>1</code> from the unsafe-coerced <code>myrect :: Ptr ()</code>.</p>
<p>Let us write the Haskell function that we will export in the Haskell foreign
library <code>MyForeignLib.hs</code> (after copying over the last <code>Rect</code> definition). This
function returns a <code>Ptr ()</code>, where the unit type has no
real meaning as we coerce it away, knowing that the pointer points to a <code>Rect</code> in
memory that can be understood by Swift as a <code>Rect</code> struct.</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="ot">give_rect ::</span> <span class="dt">Ptr</span> ()</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>give_rect <span class="ot">=</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Step 1</span></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>    tagged_ptr <span class="ot">=</span> unsafeCoerce<span class="ot"> myrect ::</span> <span class="dt">Ptr</span> ()</span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Step 1.5</span></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a>    ptr_minus_1 <span class="ot">=</span> (unsafeCoerce<span class="ot"> tagged_ptr ::</span> <span class="dt">Word</span>) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a>    ptr_con_info <span class="ot">=</span> unsafeCoerce<span class="ot"> ptr_minus_1 ::</span> <span class="dt">Ptr</span> ()</span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Step 2</span></span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a>    ptr_final <span class="ot">=</span> ptr_con_info <span class="ot">`plusPtr`</span> <span class="dv">8</span><span class="ot"> ::</span> <span class="dt">Ptr</span> () <span class="co">-- 8 bytes</span></span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a>   <span class="kw">in</span> ptr_final</span>
<span id="cb42-12"><a href="#cb42-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-13"><a href="#cb42-13" aria-hidden="true" tabindex="-1"></a>foreign export ccall<span class="ot"> give_rect ::</span> <span class="dt">Ptr</span> ()</span></code></pre></div>
<p>On the Swift side we need simply to de-reference a <code>Rect</code> from the pointer to
the Haskell memory. In <code>ContentView</code> we add:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode swift"><code class="sourceCode swift"></code></pre></div>
<h2 data-number="4.4" id="conclusion"><span class="header-section-number">4.4</span> Conclusion</h2>
<p>As you may have come to understand, this approach in practice, despite fun, is
pretty much the horrifying opposite of robust – given how much we are relying
on the undefined memory layout of Swift, GHC optimisations, unsafe coerce, and
just so much undefined behaviour in general.</p>
<p>We only skimmed the surface of it despite having simplified it
massively. For example, if we weren’t using a top-level binding, we’d have to
worry about the garbage collector getting to the heap object before Swift could
(and instead we’d have to use something like <code>StablePtr</code>).</p>
<p>The veredict is that this is not a reasonable option to be considered for the
large applications mixing Haskell and Swift that are our goal.</p>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>As an exercise, check this by looking at the <code>C--</code> representation of the
program compiled with optimisations, with the integer fields being strict, but
without using the <code>UNPACK</code> pragma<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>Really, the <code>myrect</code> value is not in the heap as it is static
data put by the compiler in the data section, but for our purposes that
difference does not matter<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>Why <code>7</code>? For the slightly longer story:
because in a 64bit system, memory is aligned to 64 bits, meaning that
pointers to heap allocated memory will always have 3 bits that are
necessarily <code>0</code> valued – so we can use these 3 bits for tags – that is, we
can use tags from 0 to 7.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

</article>

    </main>
    <footer>
        <small>
            Rodrigo Mesquita &copy; 2022-2023
        </small>
    </footer>
  </body>
</html>
