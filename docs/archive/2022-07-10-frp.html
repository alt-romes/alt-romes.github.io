<!doctype html>
<html lang="en">
    <head>
        <meta http-equiv="content-type" content="text/html; charset=utf8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>romes - 2022-07-10-frp</title>
        
        <link rel="stylesheet" href="../css/default.css" />
        <link rel="stylesheet" href="../css/syntax.css" />
    </head>
    <body class="noShadow">
        <main>
            <!-- <h1>2022-07-10-frp</h1> -->
            <article>
    <section class="header">
        Posted on July 10, 2022
        
    </section>
    <section>
        <h1 id="graphics-with-haskell-reflex">Graphics with Haskell: Reflex</h1>
<p>This is the second of two parts on displaying graphics and user interfaces with
the functional programming paradigm, in Haskell.</p>
<p>In this part we’ll look at <strong>Functional Reactive Programming</strong> (or <strong>FRP</strong> for
short), and particularly on how it can be used to build an interactive UI.</p>
<h1 id="functional-reactive-programming">Functional Reactive Programming</h1>
<p>Functional reactive programming is a general paradigm well suited to programming
<em>real-time systems</em> in a high-level and functional way.</p>
<p><em>Real-time systems</em> or <em>reactive systems</em> are those that handle continuous
time-varying values, discrete events in real time, and react accordingly. A good
example of these systems is a <em>mobile robot</em>. They must take into consideration
continuous inputs like wheel speed, orientation, and discrete events such as
detection of another object.</p>
<p>The class of reactive systems we’re interested in here is interactive <em>graphical
UIs</em>. A user interface has multiple components that can be seen as discrete
events and continuous time-varying values. An input box, where one might write
their name, is an example of a time varying value (it continously changes –
whenever the user types something); a button is an example of a discrete event
in time: at certain points in time the user will click the button. This will
make more sense with practice and code samples.</p>
<p>So the promise of functional reactive programming is that we can program these
complicated reactive systems in a pure functional way. But how?</p>
<p>Functional Reactive Programming introduces two key concepts: <strong>Behaviours</strong> and <strong>Events</strong>.</p>
<ul>
<li><p><strong>Behaviours</strong> are first-class values that vary over continuous time.</p>
<p>That means a behaviour is a value that changes with time and can be passed
to/returned by functions.</p></li>
<li><p><strong>Events</strong> are first-class values that occur at some points in time.</p>
<p>They may refer, e.g., to happenings in the real world time – such as a
mouse click or a key press.</p></li>
</ul>
<p>And then, it says that the FRP implementation will handle all time-related
details so that the programmer can describe their <em>reactive system</em> without
thinking about what happens at <strong>any</strong> particular point in time, but rather thinking
about what happens accross <strong>all</strong> points in time.</p>
<p>This type of <em>wholemeal programming</em> (working with the whole, not the individual
part) is quite common in functional programming. When working with lists, the
same pattern appears: we think and define functions in terms of entire lists,
rather than about any particular element in the list.</p>
<p>Functional reactive programming just takes it further by abstracting over <em>time
itself</em>.</p>
<p>In the end, the programmer doesn’t need to worry about any of the <em>how</em>, just
the <em>what</em> (which quite nicely aligns with the original paper on FRP[1], which
distinguishes <em>presentation</em> from <em>modelling</em>). So, we manipulate time-dependent
<em>behaviours</em> and <em>events</em>, but we never directly see the <em>time</em>.</p>
<p>In fact, both <strong>Behaviors</strong> and <strong>Events</strong> are usually <em>abstract data types</em>,
meaning we don’t even need to know how they are defined.</p>
<p>Later we’ll see what this actually looks like.</p>
<ul>
<li>[1] <em>Functional Reactive Animation, …</em></li>
</ul>
<h1 id="behaviours">Behaviours</h1>
<p>A <strong>Behaviour</strong> is a first-class value that varies over continuous time. In
other words, a Behaviour is a value that can be passed to and returned by
functions (is first-class) and this value is defined for all time (and can
change accross time)</p>
<p>Intuitively, it can be seen as a function from time to value (<code>b :: Time -&gt; Value</code>) and
could be visualized as:</p>
<p><img src="https://github.com/hansroland/reflex-dom-inbits/raw/master/images//behavior.png" /></p>
<p>Note how this function is pure (there are no side effects): we simply map all
points in time to a value.</p>
<p>A behaviour is an abstract type constructor, meaning we know nothing about its
data constructors. We interact with behaviours through the combinators
and functions defined by the FRP implementation we’re using. The type parameter
of <code>Behavior</code> indicates the type of the values.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Behavior</span> a</span></code></pre></div>
<p>Behaviors are usually <strong>Functors</strong> (it depends on the FRP implementation, in
<em>Reflex</em> they are). We can imagine that if we have a behaviour (<code>x :: Behavior Int</code>) which is for all points in time equal to 1 (you might imagine the 2D graph
of the constant math function <code>f(x) = 1</code>), there is an easy way to define a
behavior <code>y</code> which is constantly equal to 2: <code>fmap (+1) x :: Behavior Int</code>.</p>
<p>Let’s write a short example of a function that transforms a <code>Behavior String</code>
into a <code>Behavior (Maybe Color)</code></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Color</span> <span class="ot">=</span> <span class="dt">Yellow</span> <span class="op">|</span> <span class="dt">Magenta</span> <span class="op">|</span> <span class="dt">Cyan</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="ot">color ::</span> <span class="dt">Behavior</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Behavior</span> (<span class="dt">Maybe</span> <span class="dt">Color</span>)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>color bstr <span class="ot">=</span> <span class="fu">fmap</span> toColor bstr</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    toColor <span class="st">&quot;yellow&quot;</span>  <span class="ot">=</span> <span class="dt">Just</span> <span class="dt">Yellow</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    toColor <span class="st">&quot;magenta&quot;</span> <span class="ot">=</span> <span class="dt">Just</span> <span class="dt">Magenta</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    toColor <span class="st">&quot;cyan&quot;</span>    <span class="ot">=</span> <span class="dt">Just</span> <span class="dt">Cyan</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    toColor _         <span class="ot">=</span> <span class="dt">Nothing</span></span></code></pre></div>
<p>An example of a behaviour we’ll use is the value in an input text box. This box
has a string at all times. Before the user writes anything, the value is the
empty string. The value at some time after the user has written “123” is “123.</p>
<h1 id="events">Events</h1>
<p>An <strong>Event</strong> is a first-class value that occurs at discrete points in time. In
other words, an Event is a value that can be passed to and returned by
functions (is first-class) and this value is defined at only some points in
time. If the event is occuring, <em>and if it is</em>, what its
value is.</p>
<p>It’s a bit harder to think about intuitively, but one can imagine an event as a
function from time to maybe a value (<code>e :: Time -&gt; Maybe Value</code>) or as a list of
values and the times at which they occur (<code>e :: [(Time, Value)]</code>).</p>
<p><img src="https://github.com/hansroland/reflex-dom-inbits/raw/master/images//event.png" /></p>
<p>An event is also an abstract type constructor, meaning we know nothing about its
data constructors. As with behaviors, we interact with events through the combinators
and functions defined by the FRP implementation we’re using. The type parameter
of <code>Event</code> also indicates the type of the values.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Event</span> a</span></code></pre></div>
<p>Above, <code>a</code> is the type of the value the event carries when it occurs.</p>
<p>Events are functors! You can think of them being functors the same way you would about
Behaviors.</p>
<p>An example of an event we’ll use is the one generated by a button. Everytime the
button is clicked, an event occurs of type <code>Event ()</code> (a button click has no
associated value, unlike, e.g., key presses, which would have type <code>Event Char</code>).</p>
<p>Ahead we’ll see how we can manipulate and put together events and behaviors to
build a reactive application.</p>
<h1 id="reflex">Reflex</h1>
<p><a href="https://hackage.haskell.org/package/reflex">Reflex</a> is a haskell library for
functional reactive programming in haskell.</p>
<blockquote>
<p>Interactive programs without callbacks or side-effects. Functional Reactive
Programming (FRP) uses composable events and time-varying values to describe
interactive systems as pure functions. Just like other pure functional code,
functional reactive code is easier to get right on the first try, maintain,
and reuse.</p>
</blockquote>
<blockquote>
<p>Reflex is a fully-deterministic, higher-order Functional Reactive Programming
interface and an engine that efficiently implements that interface.</p>
</blockquote>
<p>Reflex provides the above described abstractions (behaviors and events),
functions to work with them, and an additional abstraction called <strong>Dynamics</strong>.
For our intents and purposes, <strong>we’ll consider dynamics to be the same as
behaviors</strong>, since discussing the details of it would be out of the scope of
this tutorial[2].</p>
<ul>
<li>[2] In a <em>very</em> short note: Reflex is implemented with push-pull evaluation,
and thus often requires explicit push notifications to update things like
the DOM. Event push notifications when they occur, but Behaviors don’t push
anything. A Dynamic is a combination of an Event and Behavior, meaning it’s
a continuous time-varying value that pushes notification whenever it
changes, and fills the spaces where we need a behaviour <em>and</em> to know when
the value changes.</li>
</ul>
<h1 id="building-uis-with-reflex-dom">Building UIs with Reflex-Dom</h1>
<p>To build a UI we’ll use
<a href="https://hackage.haskell.org/package/reflex-dom">reflex-dom</a> which is a haskell
library that provides a monadic interface for building a DOM-based UI with
functional reactive programming abstractions from <em>reflex</em>.</p>
<p>A DOM user interface is defined with element tags. A webpage can have many
elements such as <em>divisions</em> and text <em>paragraphs</em>.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode html"><code class="sourceCode html"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;div&gt;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">&lt;p&gt;</span>This is a paragraph.<span class="kw">&lt;/p&gt;</span> </span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">&lt;button&gt;</span>Button below the paragraph<span class="kw">&lt;/button&gt;</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;/div&gt;</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;div&gt;</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">&lt;p&gt;</span>This is the second division.<span class="kw">&lt;/p&gt;</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">&lt;input&gt;&lt;/input&gt;</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;/div&gt;</span></span></code></pre></div>
<p>Would define a webpage with two divisions (<code>&lt;div&gt;</code>). The first division has a
paragraph (<code>&lt;p&gt;</code>) and a button (<code>&lt;button&gt;</code>), the second, a paragraph and and a
text-box for input (<code>&lt;input&gt;</code>).</p>
<p>Reflex-dom defines the <code>Widget</code> monad[3] and multiple functions with which we can
create our UI. However, some of these functions do more than build the UI: they
return and accept events and behaviors! Let’s look at a few.</p>
<p>We can put text on the UI, without creating a new element. Notice how the
returned <code>Widget</code> is a computation that builds the UI and the resulting value of
the said computation has type <code>()</code>.</p>
<pre><code>text :: Text -&gt; Widget ()</code></pre>
<p>The most basic element-creating function is <code>el</code>. It takes the name of the
element as a string, a <code>Widget</code> computation, and returns another <code>Widget</code>
computation. This still does nothing regarding FRP.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">el ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Widget</span> a <span class="ot">-&gt;</span> <span class="dt">Widget</span> a</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>ex1 <span class="ot">=</span> el <span class="st">&quot;p&quot;</span> (text <span class="st">&quot;This is a paragraph&quot;</span>)</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- would correspond to</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- &lt;p&gt;This is a paragraph&lt;/p&gt;</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>ex2 <span class="ot">=</span> el <span class="st">&quot;div&quot;</span> (el <span class="st">&quot;p&quot;</span> (text <span class="st">&quot;Other paragraph&quot;</span>))</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="co">-- would correspond to</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="co">-- &lt;div&gt;</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a><span class="co">--      &lt;p&gt;This is a paragraph&lt;/p&gt;</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="co">-- &lt;/div&gt;</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>ex3 <span class="ot">=</span> el <span class="st">&quot;div&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>        el <span class="st">&quot;p&quot;</span> (text <span class="st">&quot;First paragraph&quot;</span>)</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>        el <span class="st">&quot;p&quot;</span> (text <span class="st">&quot;Second paragraph&quot;</span>)</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a><span class="co">-- would correspond to</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a><span class="co">--  &lt;div&gt;</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a><span class="co">--      &lt;p&gt;First paragraph&lt;/p&gt;</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a><span class="co">--      &lt;p&gt;Second paragraph&lt;/p&gt;</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a><span class="co">--  &lt;div&gt;</span></span></code></pre></div>
<p>A button can be clicked at some points in time. We can model a button click with
an event! There is a convenient function that returns a <code>Widget</code> computation
that creates a button and returns an event that occurs when the button is
clicked. We’ll see ahead an example in which we this event.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">button ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Widget</span> (<span class="dt">Event</span> t ()) </span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>ex4 <span class="ot">=</span> el <span class="st">&quot;div&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>        el <span class="st">&quot;p&quot;</span> (text <span class="st">&quot;Before button&quot;</span>)</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>        clickEvt <span class="ot">&lt;-</span> button <span class="st">&quot;Click me!&quot;</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>        el <span class="st">&quot;p&quot;</span> (text <span class="st">&quot;After button&quot;</span>)</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- would correspond to</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="co">--  &lt;div&gt;</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="co">--      &lt;p&gt;Before button&lt;/p&gt;</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="co">--      &lt;button&gt;Click me!&lt;/button&gt;</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a><span class="co">--      &lt;p&gt;After button&lt;/p&gt;</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a><span class="co">--  &lt;div&gt;</span></span></code></pre></div>
<p>An input text box has a continuous time-varying value: What the user has input
in the box. We can model the value inside the input box with a behavior! As with
the button, we already have a function that returns a <code>Widget</code> computation that
creates an input box and which returns a behavior of the value in the text box.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">input ::</span> <span class="dt">Widget</span> (<span class="dt">Dynamic</span> <span class="dt">Text</span>)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>ex5 <span class="ot">=</span> el <span class="st">&quot;div&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>        inputBehavior <span class="ot">&lt;-</span> input</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>        <span class="fu">return</span> ()</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- would correspond to</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="co">--  &lt;div&gt;</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="co">--      &lt;input&gt;&lt;/input&gt;</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a><span class="co">--  &lt;div&gt;</span></span></code></pre></div>
<p>Lastly, we have a function for displaying a behavior of a string. Whatever the
value of the string is at the current time, is what’s displayed on the string.
Non-surprisingly, this function is called <code>dynText</code>.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">dynText ::</span> <span class="dt">Dynamic</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Widget</span> ()</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>ex6 <span class="ot">=</span> el <span class="st">&quot;div&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>        inputBehavior <span class="ot">&lt;-</span> input</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>        el <span class="st">&quot;p&quot;</span> (dynText inputBehavior)</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- what would this look like?</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- &lt;div&gt;</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a><span class="co">--      &lt;input&gt;&lt;/input&gt;</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a><span class="co">--      &lt;p&gt;???&lt;/p&gt;</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a><span class="co">-- &lt;/div&gt;</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a><span class="co">-- not so simple, would require javascript</span></span></code></pre></div>
<p>Next we’ll look at some UI-independent combinators on events and behaviors, and
at a few examples of how we can use them in building more complex UIs.</p>
<ul>
<li>[3] In fact, <code>Widget x</code> is the monad (<code>Widget :: * -&gt; * -&gt; *</code>), where <code>x</code>
is a type parameter to guarantee contexts don’t get mixed.</li>
</ul>
<h1 id="reflex-combinators">Reflex Combinators</h1>
<h1 id="acknowledgments">Acknowledgments</h1>
<p>Ask John to review this?</p>
    </section>
</article>

        </main>
        <nav>
            <ul>
                <li class="logo"><a href="../">romes</a></li>
                <li><a href="../archive.html">archive</a></li>
                <li>music</li>
                <li><a href="../papers.html">papers</a></li>
                <li><a href="https://github.com/alt-romes" target="_blank">github</a></li>
                <br />
                <button onclick="document.body.classList.toggle('dark')">*</button>
                <br />
                <button onclick="document.body.classList.toggle('noShadow')">**</button>
            </ul>
        </nav>
        <script>
            opt = ['bengali', 'cambodian', 'devanagari', 'georgian', 'hebrew', 'kannada', 'lao', 'mongolian', 'myanmar', 'oriya', 'thai', 'tibetan', 'hiragana', 'katakana-iroha']; // 'cjk-earthly-branch', 'cjk-heavenly-stem',
            r = Math.floor(Math.random() * opt.length);
            Array.prototype.map.call(document.getElementsByTagName('ul'), x => x.style['list-style-type'] = opt[r]);
        </script>
    </body>
</html>
