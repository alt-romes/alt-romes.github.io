<!doctype html>
<html lang="en">
    <head>
        <meta http-equiv="content-type" content="text/html; charset=utf8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>romes - Lecture 2</title>
        
        <link rel="stylesheet" href="../css/default.css" />
        <link rel="stylesheet" href="../css/syntax.css" />
    </head>
    <body class="noShadow">
        <main>
            <!-- <h1>Lecture 2</h1> -->
            <article>
    <section class="header">
        
            Posted on May  8, 2022
        
        
    </section>
    <section>
        <h1 id="functions-types-currying-partial-application-higher-order-functions">Functions Types, Currying, Partial application, Higher-order functions</h1>
<p>All functions have a type, the <em>function type</em>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">length</span><span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">length</span> [] <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="fu">length</span> (x<span class="op">:</span>xs) <span class="ot">=</span> <span class="dv">1</span> <span class="op">+</span> <span class="fu">length</span> xs</span></code></pre></div>
<p>The same way we think about the <code>Either</code> type constructor, and about the tuple
type constructor <code>(,)</code>, we can think about the function type type constructor
(the arrow <code>-&gt;</code>). They are all type constructors that take two arguments.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Either</span> a b <span class="ot">=</span> <span class="dt">Left</span> a <span class="op">|</span> <span class="dt">Right</span> b</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> (,) a b <span class="ot">=</span> (a, b)     <span class="co">-- pseudo code</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> (<span class="ot">-&gt;</span>) a b <span class="ot">=</span> a <span class="ot">-&gt;</span> b    <span class="co">-- pseudo code</span></span></code></pre></div>
<p>This means that the <code>(-&gt;)</code> type constructor, when applied to two types <code>a</code> and <code>b</code>, creates
a new type <code>a -&gt; b</code>, where <code>a</code> is the input type and <code>b</code> the return type.</p>
<p>This beggets the question, what is the type of a function that takes two
arguments? There are two ways to define multi-argument functions.</p>
<p>The first would be to think about functions that receive multiple arguments in a
tuple.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">prepend ::</span> (<span class="dt">Char</span>, <span class="dt">String</span>) <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>prepend (c, str) <span class="ot">=</span> c<span class="op">:</span>str</span></code></pre></div>
<p>You could even use it like this <code>prepend('h', "ello")</code>, which somewhat resembles
the imperative style function call.</p>
<p>The second option is to have a function take one argument <code>a</code>, and return a
function that takes another argument <code>b</code> and only then returns <code>c</code>.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">prepend ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> (<span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>prepend c <span class="ot">=</span> (\str <span class="ot">-&gt;</span> c<span class="op">:</span>str)</span></code></pre></div>
<p>And this is the most common way to have multi-argument functions in functional
programming languages. In Haskell, thinking about two argument functions and
functions that return functions is really the same thing.</p>
<p>The most common way of writing the two argument function <code>prepend</code> in Haskell,
read “<code>prepend</code> is a function that takes <em>two</em> arguments of type <code>Char</code> and <code>String</code>
and returns <code>String</code>”, would be</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">prepend ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>prepend c str <span class="ot">=</span> c<span class="op">:</span>str</span></code></pre></div>
<p>The <code>(Char, String) -&gt; String</code> version is said to be an <em>uncurried</em> function,
while <code>Char -&gt; String -&gt; String</code> is said to be <em>curried</em>.</p>
<p>An advantage in using <em>curried</em> functions is the possibility to partially apply
them.</p>
<p>We can define a new function that always prepends <code>B</code> in terms of <code>prepend</code> by
partially applying <code>prepend</code> (that is, applying the function to a partial number
of arguments)</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>prependB <span class="ot">=</span> prepend <span class="ch">'B'</span></span></code></pre></div>
<p>Partial application is useful in everyday functional programming; A common
example is passing partially applied functions to functions that take functions:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">map</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- Given a list of strings, prepend C to them all</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="ot">prependAll ::</span> [<span class="dt">String</span>] <span class="ot">-&gt;</span> [<span class="dt">String</span>]</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>prependAll strs <span class="ot">=</span> <span class="fu">map</span> (prepend <span class="ch">'C'</span>) strs</span></code></pre></div>
<p>In functional programming, functions are <em>first-class</em>, meaning they can be
passed as parameters and returned from functions. Functions used in those ways
are said to be higher-order functions</p>
<p>As an end note on function types, notice that the “correct use” of <code>-&gt;</code> type constructor is enforced by the
kind system, the same way the usage of <code>Either</code> is enforced by the kind system.
The kinds of these type constructors are:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Either</span><span class="ot"> ::</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> (,)<span class="ot">    ::</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span><span class="ot"> (-&gt;)   ::</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span></span></code></pre></div>
<p>To have a function type we must supply both type arguments to the <code>-&gt;</code> type
constructor (i.e. <code>Int -&gt; Char</code> is a valid <em>type</em>), but what happens if we
<em>partially apply</em> the type constructor?</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> (<span class="ot">-&gt;</span>) <span class="dt">Int</span><span class="ot"> ::</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">FunctionFromInt</span> <span class="ot">=</span> (<span class="ot">-&gt;</span>) <span class="dt">Int</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">FunctionFromInt</span> <span class="dt">Char</span><span class="ot"> ::</span> <span class="op">*</span> <span class="co">-- equivalent to `Int -&gt; Char`</span></span></code></pre></div>
<h1 id="laziness">Laziness</h1>
<p><small>This section derives from <a href="https://www.haskell.org/tutorial/functions.html">A Gentle Introduction to Haskell</a></small></p>
<p>Suppose <code>bot</code> is defined by:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>bot <span class="ot">=</span> bot</span></code></pre></div>
<p>In other words, <code>bot</code> is a non-terminating expression. Abstractly, we denote the
value of a non-terminating expression as <em>|</em>. Expressions that result in some
kind of a run-time error, such as 1/0, also have this value. Such an error is
not recoverable: programs will not continue past these errors.</p>
<p>A function <code>f</code> is said to be <em>strict</em> if, when applied to a nonterminating
expression, it also fails to terminate. In other words, f is <em>strict</em> iff the
value of <code>f bot</code> is <code>bot</code>. For most programming languages, all functions are strict.
But this is not so in Haskell.</p>
<p>As a simple example, consider const1, the constant 1 function, defined by:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>const1 x <span class="ot">=</span> <span class="dv">1</span></span></code></pre></div>
<p>The value of <code>const1 bot</code> in Haskell is <code>1</code>. Operationally speaking, since <code>const1</code>
does not <em>need</em> the value of its argument, it never attempts to evaluate it, and
thus never gets caught in a nonterminating computation. For this reason,
non-strict functions are also called <em>lazy functions</em>, and are said to evaluate
their arguments <em>lazily</em>, or <em>by need</em>.</p>
<p>Another way of explaining non-strict functions is that Haskell computes using
definitions rather than the assignments found in traditional languages. Read a
declaration such as</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>v <span class="ot">=</span> <span class="dv">1</span><span class="op">/</span><span class="dv">0</span></span></code></pre></div>
<p>as define <code>v</code> as <code>1/0</code> instead of compute <code>1/0</code> and store the result in <code>v</code>. Only if
the value (definition) of <code>v</code> is needed will the division by zero error occur. By
itself, this declaration does not imply any computation. Programming using
assignments requires careful attention to the ordering of the assignments: the
meaning of the program depends on the order in which the assignments are
executed. Definitions, in contrast, are much simpler: they can be presented in
any order without affecting the meaning of the program.</p>
<h1 id="recursion-inductive-method">Recursion: Inductive Method</h1>
<p>Inspired on <a href="http://ctp.di.fct.unl.pt/~amd/lap/teoricas/03.html">AMD - Teórica 3</a>.</p>
<p>A well defined recursive function does case analysis over its parameters.</p>
<p>The <strong>base cases</strong> are the ones that don’t lead to recursive calls of the
function. The <strong>general cases</strong> are those that lead to, directly or indirectly,
recursive calls of the function.</p>
<p>The <em>inductive method</em> helps the programmer reason about the logical properties
of the problem to solve:
* The trivial case should be dealt with trivially
* The general case should be dealt with by <em>reducing the problem to a simpler
problem</em>
When reducing the problem to a simpler one, assume the simpler one is already
solved, and try to form the result based on that answer. In practice, the
simpler problem is solved by the recursive call.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>fact <span class="dv">0</span> <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>fact n <span class="ot">=</span> n <span class="op">*</span> fact (n<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="fu">length</span> [] <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="fu">length</span> (x<span class="op">:</span>xs) <span class="ot">=</span> <span class="dv">1</span> <span class="op">+</span> <span class="fu">length</span> xs</span></code></pre></div>
<p>Analysing these recursive functions, we note that when dealing with the
<strong>general case</strong> (the non-trivial case), they both <em>reduce the original problem
to a simpler instance</em> of the same problem. the <code>length</code> function reduces the
original problem <code>length (x:xs)</code> to the simpler <code>length xs</code>, and the function
<code>fact</code> reduces the problem <code>fact n</code> to the simler problem <code>fact (n-1)</code>.</p>
<p>Assuming the simpler problem is already solved (what is the length of <code>xs</code>?), we
can just think about the step to take to the solution, which is add <code>1</code> to the
recursive call result.</p>
<h1 id="recursive-data-structures">Recursive data structures</h1>
<p>Data structures can use themselves to define themselves, or in other words,
define themselves recursively. When they do so, they can be called <em>recursive
data types</em>.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Tree</span> a <span class="ot">=</span> <span class="dt">Leaf</span> <span class="op">|</span> <span class="dt">Node</span> a (<span class="dt">Tree</span> a) (<span class="dt">Tree</span> a)</span></code></pre></div>
<p>A <code>Tree</code> here is defined in terms of other <code>Tree</code>s. A <code>Tree</code> of <code>a</code>s can be either a
<code>Leaf</code> or a <code>Node</code> with a value of type <code>a</code> and two subtrees.</p>
<p>Recursive data types are expressive kinds of structures and a very idiom in
functional programming. For example, we can clearly express a simple calculator
language through a recursive data type <code>Expr</code>.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Expr</span> <span class="ot">=</span> <span class="dt">Const</span> <span class="dt">Int</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>          <span class="op">|</span> <span class="dt">Add</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>          <span class="op">|</span> <span class="dt">Mult</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span></code></pre></div>
<p>This way, we can represent numerical expressions in through our datatype:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- 5</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Const</span> <span class="dv">5</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- 6 * 2</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="dt">Mult</span> (<span class="dt">Const</span> <span class="dv">6</span>) (<span class="dt">Const</span> <span class="dv">2</span>)</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- 2 + 3 * 4</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a><span class="dt">Mult</span> (<span class="dt">Add</span> (<span class="dt">Const</span> <span class="dv">2</span>) (<span class="dt">Const</span> <span class="dv">3</span>)) (<span class="dt">Const</span> <span class="dv">4</span>)</span></code></pre></div>
<p>And easily define recursive operations on it:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="ot">calculate ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>calculate (<span class="dt">Const</span> i) <span class="ot">=</span> i</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>calculate (<span class="dt">Add</span> x y) <span class="ot">=</span> calculate x <span class="op">+</span> calculate y</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>calculate (<span class="dt">Mult</span> x y) <span class="ot">=</span> calculate x <span class="op">*</span> calculate y</span></code></pre></div>
<p>Because of Haskell’s laziness, we can even make infinite values of this recursive type.</p>
<p>Write a function that creates an infinite tree of length <code>n</code> given <code>n :: Int</code></p>
<div class="sourceCode" id="cb18"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="ot">infiniteTree ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Tree</span> a</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>infiniteTree <span class="ot">=</span> <span class="fu">undefined</span></span></code></pre></div>
<p>What about an expression that infinitely adds <code>n</code>?</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- infiniteAdd 5 &lt;=&gt; 5 + 5 + 5 + ... + 5 + ... + 5 + ...</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="ot">infiniteAdd ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>infiniteAdd <span class="ot">=</span> <span class="fu">undefined</span></span></code></pre></div>
<p>One can then write functions to make use of these infinite structures. For
example, a function that given an infinite expression of adding <code>n</code>, adds <code>n</code>
<code>k</code> amount of times (that is, a function that multiplies <code>n</code> by <code>k</code> through
creating an infinite addition expression).</p>
<p>The most common example of an infinite structure is the infinite list and
operations on it</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span><span class="op">..</span>] <span class="co">-- [1,2,3,4,5,6,7......</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="fu">take</span> <span class="dv">5</span> [<span class="dv">1</span><span class="op">..</span>] <span class="co">-- [1,2,3,4,5]</span></span></code></pre></div>
<p>Could you write a generator of infinite lists starting at <code>n</code>?</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">List</span> a <span class="ot">=</span> <span class="dt">Nil</span> <span class="op">|</span> <span class="dt">Cons</span> a (<span class="dt">List</span> a)</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="ot">infList ::</span> n <span class="ot">-&gt;</span> <span class="dt">List</span> a</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>infList <span class="ot">=</span> <span class="fu">undefined</span></span></code></pre></div>
<h1 id="type-classes">Type Classes</h1>
<p>Previously we saw <em>parametric polymorphism</em>, and how a function needed to treat the polymorphic
types agnostically, that is, the polymorphic type could be instanced by any type
and the expression would still be valid. A common example is the map function</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="fu">map</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="fu">map</span> _ [] <span class="ot">=</span> []</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="fu">map</span> f (x<span class="op">:</span>xs) <span class="ot">=</span> f x<span class="op">:</span><span class="fu">map</span> f xs</span></code></pre></div>
<p>In which the elements of the list are treated agnostically – they could have any
type and this function would still typecheck.</p>
<p>Sometimes, however, we desire a function to be polymorphic over just some types,
for example, a function polymorphic over all types for which equality <code>(==)</code> is
defined.</p>
<p>We don’t want to define multiple equal functions just with different types,
neither do we want a fully polymorphic function because equality isn’t defined
for all types (e.g. the <code>Expr</code>s we created previously).</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="ot">allEqual1 ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="ot">allEqual2 ::</span> [<span class="dt">Char</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="ot">allEqual3 ::</span> [<span class="dt">Bool</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a><span class="ot">allEqual4 ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="co">-- how to compare a?</span></span></code></pre></div>
<p>That’s where <em>type-class polymorphism</em> (also known as <em>ad-hoc polymorphism</em>)
comes into play. We can define a <strong>type class</strong> which corresponds to a set of
types which have certain operations defined for them, and we can define
<em>type-class polymorphic</em> functions which can only be called on types which
instance the said type-class.</p>
<p>Let’s define a type class for equality. Any <em>type</em> that <em>instances</em> this <em>type
class</em> <code>Eq</code>, or in other words, any <em>type</em> that belongs to the <em>set of types</em> that
support the equality comparison <code>(==)</code>, well, can be compared using <code>==</code>.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>      <span class="op">+</span> <span class="co">--- class name</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>      <span class="op">|</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>      v</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Eq</span> a <span class="kw">where</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a><span class="ot">    (==) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>      <span class="op">^</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>      <span class="op">|</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>      <span class="op">+</span> <span class="co">--- operation that must be defined for all instances of `Eq`</span></span></code></pre></div>
<p>We can then define <em>type-class polymorphic</em> functions such as <code>allEqual</code>, which
take a polymorphic type <code>a</code>, as long as <code>a</code> instances <code>Eq</code> (<code>Eq a =&gt; a</code>).</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>             <span class="op">+</span> <span class="co">-- Constraint</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>             <span class="op">|</span>          <span class="op">+</span> <span class="co">-- Function type, where `a` must instance `Eq`</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>             v          v</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>            _____   ___________</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a><span class="ot">allEqual ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>allEqual [] <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>allEqual [x] <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>allEqual (x<span class="op">:</span>y<span class="op">:</span>xs) <span class="ot">=</span> x <span class="op">==</span> y <span class="op">&amp;&amp;</span> allEqual xs</span></code></pre></div>
<p>If we then called <code>allEqual</code> on a list of <code>Expr</code>, it still wouldn’t work –
that’s because <code>Expr</code> doesn’t instance <code>Eq</code> (how do you compare two <code>Expr</code>?)</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>allEqual [<span class="dt">Const</span> <span class="dv">5</span>, <span class="dt">Const</span> <span class="dv">5</span>, <span class="dt">Add</span> (<span class="dt">Const</span> <span class="dv">6</span>) (<span class="dt">Const</span> <span class="dv">7</span>)]</span></code></pre></div>
<p>To define an <em>instance</em> of a type class for some type, we use the <code>instance</code>
keyword in the following way:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>         <span class="op">+</span> <span class="co">--- class name</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>         <span class="op">|</span>   <span class="op">+</span> <span class="co">--- instancing type</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>         v   v</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Eq</span> <span class="dt">Expr</span> <span class="kw">where</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a> <span class="co">-- (==) :: Expr -&gt; Expr -&gt; Bool</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>    (<span class="op">==</span>) x y <span class="ot">=</span> <span class="kw">case</span> (x,y) <span class="kw">of</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>        (<span class="dt">Const</span> i, <span class="dt">Const</span> j) <span class="ot">-&gt;</span> i <span class="op">==</span> j</span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>        (<span class="dt">Add</span> z w, <span class="dt">Add</span> k p) <span class="ot">-&gt;</span> z <span class="op">==</span> k <span class="op">&amp;&amp;</span> w <span class="op">==</span> p</span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>        (<span class="dt">Mult</span> z w, <span class="dt">Mult</span> k p) <span class="ot">-&gt;</span> z <span class="op">==</span> k <span class="op">&amp;&amp;</span> w <span class="op">==</span> p</span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a>        (_, _) <span class="ot">-&gt;</span> <span class="dt">False</span></span></code></pre></div>
<p>After which <code>allEqual [Const 2, Const 2]</code> would return <code>True</code>.</p>
<h1 id="type-classes-kinds-constraints">Type Classes Kinds, Constraints</h1>
<p>Let’s begin with this set up</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Box</span> a <span class="ot">=</span> <span class="dt">MkBox</span> a</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Eq</span> a <span class="kw">where</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    (==) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a><span class="ot">allEqual ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span></span></code></pre></div>
<p>And now let’s revisit <em>kinds</em>.
The kind of a simple type such as <code>Int</code>, is <code>*</code>.
The kind of a type constructor such as <code>Box</code> is <code>* -&gt; *</code>
The kind of a type constructor applied to a type, such as <code>Box Int</code> is <code>*</code>.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Int</span><span class="ot"> ::</span> <span class="op">*</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Box</span><span class="ot"> ::</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Box</span> <span class="dt">Int</span><span class="ot"> ::</span> <span class="op">*</span></span></code></pre></div>
<p>Now imagine there existed a kind called <code>MagicalKind</code>, and we could define type operators
that returned types of this kind</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Magic</span><span class="ot"> ::</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="dt">MagicalKind</span></span></code></pre></div>
<p>The <code>Magic</code> type operator receives a <code>*</code> and returns <code>MagicalKind</code>. <code>*</code> is a
kind, <code>MagicalKind</code> is a kind, and their combination through the kind arrow
<code>(-&gt;)</code> is also a kind.</p>
<p>If we applied <code>Magic</code> to some type, say, <code>Int</code>, we’d get something of kind
<code>MagicalKind</code>.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Magic</span> <span class="dt">Int</span><span class="ot"> ::</span> <span class="dt">MagicalKind</span></span></code></pre></div>
<p>There are other kinds besides <code>*</code> and kinds constructed with <code>-&gt;</code>. There exists
an important kind called <code>Constraint</code>, and there exist type operators that
return types of kind <code>Constraint</code>.</p>
<p>Those type operators are defined through type classes. Our <code>Eq</code> class has a
kind:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Eq</span><span class="ot"> ::</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="dt">Constraint</span></span></code></pre></div>
<p>Which means that <code>Eq</code> applied to <code>Int</code>, <code>Eq Int</code>, has kind <code>Constraint</code>.</p>
<p>It’s the kind system that enforces the correct usage of constraints and type classes.
Going back to the set up of this section, how could we create an instance of <code>Eq</code> for <code>Box</code>?</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Eq</span> <span class="dt">Box</span> <span class="kw">where</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>    (<span class="op">==</span>) <span class="ot">=</span> <span class="fu">undefined</span></span></code></pre></div>
<p>This would actually not compile! Why? Let’s inspect the kinds.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Eq</span><span class="ot"> ::</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="dt">Constraint</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Box</span><span class="ot"> ::</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Box</span><span class="ot"> a ::</span> <span class="op">*</span></span></code></pre></div>
<p>When we write <code>Eq Box</code>, <code>Eq</code> is expecting a type of kind <code>*</code>, but we pass it
<code>Box</code> of kind <code>* -&gt; *</code>!</p>
<p>A correct instance could be formulated as follows</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Eq</span> (<span class="dt">Box</span> a) <span class="kw">where</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">Box</span> x) <span class="op">==</span> (<span class="dt">Box</span> y) <span class="ot">=</span> <span class="dt">True</span> <span class="co">-- We define two boxes to be always equal</span></span></code></pre></div>
<p>Now, <code>Box a</code> has kind <code>*</code>, and so <code>Eq (Box a)</code> is correctly formulated.</p>
<p>Finally, let’s look at the <code>Constraint</code> kind. When defining a type class
polymorphic function, we use the <code>=&gt;</code> symbol. On the left side of the symbol we
must have <em>constraints</em>, and on the right, <em>types</em>. The kind system also
enforces this.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="ot">allEqual ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span></span></code></pre></div>
<p>This is a correct function definition. <code>Eq a</code> has kind <code>Constraint</code>, and so it
can comfortably sit on the left side of <code>=&gt;</code>. If we were, however, to write</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="ot">allEqual ::</span> <span class="dt">Box</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span></span></code></pre></div>
<p>We’d get an error complaining about how <code>Box a</code> should have kind <code>Constraint</code>,
but in reality has kind <code>*</code>.</p>
<p>Suggested reading: <a href="https://www.cis.upenn.edu/~cis194/spring13/lectures/05-type-classes.html">Type Classes</a></p>
    </section>
</article>

        </main>
        <nav>
            <ul>
                <li class="logo"><a href="../">romes</a></li>
                <li><a href="../posts.html">posts</a></li>
                <li>music</li>
                <!-- <li><a href="/papers.html">publications</a></li> -->
                <li><a href="https://github.com/alt-romes" target="_blank">github</a></li>
                <li><a href="https://gitlab.haskell.org/alt-romes" target="_blank">ghc</a></li>
                <br />
                <button onclick="document.body.classList.toggle('dark')">*</button>
                <br />
                <button onclick="document.body.classList.toggle('noShadow')">**</button>
            </ul>
        </nav>
        <script>
            opt = ['bengali', 'cambodian', 'devanagari', 'georgian', 'hebrew', 'kannada', 'lao', 'mongolian', 'myanmar', 'oriya', 'thai', 'tibetan', 'hiragana', 'katakana-iroha']; // 'cjk-earthly-branch', 'cjk-heavenly-stem',
            r = Math.floor(Math.random() * opt.length);
            Array.prototype.map.call(document.getElementsByTagName('ul'), x => x.style['list-style-type'] = opt[r]);
        </script>
    </body>
</html>
